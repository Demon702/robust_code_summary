Clean Code,Corrupted Code,Gold output,Prediction1,Prediction2,Shuffle_Index,Better Label
"function dd(object, _context, _key, _root, _rootPath) {
    _root = _root || object;
    _rootPath = _rootPath || [];
    var drill = function(key) {
        var nextObject = (
            object &&
            object.hasOwnProperty(key) &&
            object[key] ||
            undefined
        );
        return dd(nextObject, object, key, _root, _rootPath.concat(key));
    };
    drill.val = object;
    drill.exists = object !== undefined;
    drill.set = function(value) {
        if (_rootPath.length === 0) {
            return;
        }
        var contextIterator = _root;
        for (var depth = 0; depth < _rootPath.length; depth++) {
            var key = _rootPath[depth];
            var isFinalDepth = (depth === _rootPath.length - 1);
            if (!isFinalDepth) {
                contextIterator[key] = (
                    contextIterator.hasOwnProperty(key) &&
                    typeof contextIterator[key] === 'object' ?
                        contextIterator[key] : {}
                );
                contextIterator = contextIterator[key];
            } else {
                _context = contextIterator;
                _key = key;
            }
        }
        _context[_key] = value;
        drill.val = value;
        drill.exists = value !== undefined;
        return value;
    };
    drill.update = function(value) {
        if (drill.exists) {
            _context[_key] = value;
            drill.val = value;
            return value;
        }
    };
    drill.invoke = isFunction(object) ? Function.prototype.bind.call(object, _context) : function () {
    };

    return drill;
}","function func0(variable0, variable1, variable2, variable3, variable4) {
    variable3 = variable3 || variable0;
    variable4 = variable4 || [];
    var variable5 = function (key) {
        var nextObject = variable0 && variable0.function hasOwnProperty() { [native code] }(key) && variable0[key] || undefined;
        return func0(nextObject, variable0, key, variable3, variable4.concat(key));
    };
    variable5.val = variable0;
    variable5.exists = variable0 !== undefined;
    variable5.set = function (value) {
        if (variable4.length === 0) {
            return;
        }
        var contextIterator = variable3;
        for (var depth = 0; depth < variable4.length; depth++) {
            var key = variable4[depth];
            var isFinalDepth = depth === variable4.length - 1;
            if (!isFinalDepth) {
                contextIterator[key] = contextIterator.function hasOwnProperty() { [native code] }(key) && typeof contextIterator[key] === 'object' ? contextIterator[key] : {};
                contextIterator = contextIterator[key];
            } else {
                variable1 = contextIterator;
                variable2 = key;
            }
        }
        variable1[variable2] = value;
        variable5.val = value;
        variable5.exists = value !== undefined;
        return value;
    };
    variable5.update = function (value) {
        if (variable5.exists) {
            variable1[variable2] = value;
            variable5.val = value;
            return value;
        }
    };
    variable5.invoke = isFunction(variable0) ? Function.prototype.bind.call(variable0, variable1) : function () {
    };
    return variable5;
}",drilldown Safely accesses deep properties of objects .,Returns a function that can be used to set a value to a variable .,Creates a new context object from the given value .,0,Prediction2
"function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   “sources” entry.  This value is prepended to the individual
    //   entries in the “source” field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   “sourceRoot”, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error(""sourceMapURL could not be parsed"");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the ""/"".
      var index = parsed.path.lastIndexOf('/');
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}","function func0(variable0, variable1, variable2) {
    variable1 = variable1 || '';
    if (variable0) {
        if (variable0[variable0.length - 1] !== '/' && variable1[0] !== '/') {
            variable0 += '/';
        }
        variable1 = variable0 + variable1;
    }
    if (variable2) {
        var parsed = urlParse(variable2);
        if (!parsed) {
            throw new Error('sourceMapURL could not be parsed');
        }
        if (parsed.path) {
            var index = parsed.path.lastIndexOf('/');
            if (index >= 0) {
                parsed.path = parsed.path.substring(0, index + 1);
            }
        }
        variable1 = join(urlGenerate(parsed), variable1);
    }
    return normalize(variable1);
}",Compute the URL of a source given the the source root the source s URL and the source map s URL .,This function is the main entry point of the source map .,Generate a source map URL .,0,Prediction2
"function cdProjectRoot () {
    const projectRoot = this.getProjectRoot();
    if (!origCwd) {
        origCwd = process.env.PWD || process.cwd();
    }
    process.env.PWD = projectRoot;
    process.chdir(projectRoot);
    return projectRoot;
}","function func0() {
    const variable0 = this.getProjectRoot();
    if (!origCwd) {
        origCwd = process.env.PWD || process.cwd();
    }
    process.env.PWD = variable0;
    process.chdir(variable0);
    return variable0;
}",Cd to project root dir and return its path . Throw CordovaError if not in a Corodva project .,Set the current working directory .,Get the current working directory .,0,Prediction1
"function move(repoState, filepath, newFilepath) {
    if (filepath === newFilepath) {
        return repoState;
    }

    const initialWorkingState = repoState.getCurrentState();

    // Create new file, with Sha if possible
    const sha = WorkingUtils.findSha(initialWorkingState, filepath);
    let changeNewFile;
    if (sha) {
        changeNewFile = Change.createCreateFromSha(sha);
    } else {
        // Content not available as blob
        const blob = read(repoState, filepath);
        const contentBuffer = blob.getAsBuffer();
        changeNewFile = Change.createCreate(contentBuffer);
    }

    // Remove old file
    const removedRepoState = remove(repoState, filepath);
    // Add new file
    return ChangeUtils.setChange(removedRepoState, newFilepath, changeNewFile);
}","function func0(variable0, variable1, variable2) {
    if (variable1 === variable2) {
        return variable0;
    }
    const variable3 = variable0.getCurrentState();
    const variable4 = WorkingUtils.findSha(variable3, variable1);
    let variable5;
    if (variable4) {
        variable5 = Change.createCreateFromSha(variable4);
    } else {
        const blob = read(variable0, variable1);
        const contentBuffer = blob.getAsBuffer();
        variable5 = Change.createCreate(contentBuffer);
    }
    const variable6 = remove(variable0, variable1);
    return ChangeUtils.setChange(variable6, variable2, variable5);
}",Rename a file,Remove a file from the working set .,This function is used to remove a variable from the working set .,1,Prediction1
"function arrIncludes (arr, values) {
  if (!Array.isArray(values)) { return inArray(arr, values) }
  var len = values.length;
  var i = -1;

  while (i++ < len) {
    var j = inArray(arr, values[i]);
    if (j) {
      return j
    }
  }

  return false
}","function func0(variable0, variable1) {
    if (!Array.isArray(variable1)) {
        return inArray(variable0, variable1);
    }
    var variable2 = variable1.length;
    var variable3 = -1;
    while (variable3++ < variable2) {
        var variable4 = inArray(variable0, variable1[variable3]);
        if (variable4) {
            return variable4;
        }
    }
    return false;
}",> Check any of values exists on arr .,Returns true if variable0 is a member of variable1,Returns the index of the first element in an array .,0,Tie
"function find_attr_value(attrForms, attrName) {
  var attrVal;
  var attrPos = -1;
  if(attrForms && Array.isArray(attrForms)) {
    attrKey = attrForms.find(function (form, i) {
      attrPos = i;
      return (i % 2 === 1) && form.value === attrName;
    })
    if(attrKey && attrPos+1 < attrForms.length) {
      attrVal = attrForms[attrPos+1];
    }
  }
  return attrVal;
}","function func0(variable0, variable1) {
    var variable2;
    var variable3 = -1;
    if (variable0 && Array.isArray(variable0)) {
        attrKey = variable0.find(function (form, i) {
            variable3 = i;
            return i % 2 === 1 && form.value === variable1;
        });
        if (attrKey && variable3 + 1 < variable0.length) {
            variable2 = variable0[variable3 + 1];
        }
    }
    return variable2;
}",find the value form with the given name in the attribute forms otherwise undefined,Returns the value of variable1 in variable0,Get the value of an attribute in an array .,0,Prediction2
"function checkDir () {
  var n = indexes[i]
  if (i > 44) {
    indexes[i] = (indexes[i] + 5) % list.length
  }
  i = (i + 1) % indexes.length
  var dir = list[n]
  if (dir) {
    fs.stat(dir, function (e, stat) {
      if (!e && (stat.mtime > okToNotifyAfter)) {
        fs.readdir(dir, function (e, files) {
          if (!e) {
            files.forEach(function (file) {
              var path = dir + '/' + file
              fs.stat(path, function (e, stat) {
                if (!e && (stat.mtime > okToNotifyAfter)) {
                  notify(path)
                }
              })
            })
          }
        })
      }
    })
  }
}","function func0() {
    var variable0 = indexes[i];
    if (i > 44) {
        indexes[i] = (indexes[i] + 5) % list.length;
    }
    i = (i + 1) % indexes.length;
    var variable1 = list[variable0];
    if (variable1) {
        fs.stat(variable1, function (e, stat) {
            if (!e && stat.mtime > okToNotifyAfter) {
                fs.readdir(variable1, function (e, files) {
                    if (!e) {
                        files.forEach(function (file) {
                            var path = variable1 + '/' + file;
                            fs.stat(path, function (e, stat) {
                                if (!e && stat.mtime > okToNotifyAfter) {
                                    notify(path);
                                }
                            });
                        });
                    }
                });
            }
        });
    }
}",Check a directory for changes .,Check if there is a file in the list .,This function is called at the beginning of the function,1,Prediction1
"function read_keyword_summary(input, offset) {
      var scanner = Scanner(input);
      scanner.forward(offset);
      return {
        num_blocks:           scanner.readNum(),
        num_entries:          scanner.readNum(),
        key_index_decomp_len: _v2 && scanner.readNum(),  // Ver >= 2.0 only
        key_index_comp_len:   scanner.readNum(),
        key_blocks_len:       scanner.readNum(),
        chksum:               scanner.checksum_v2(),
        // extra field
        len:                  scanner.offset() - offset,  // actual length of keyword section, varying with engine version attribute
      };
    }","function func0(variable0, variable1) {
    var variable2 = Scanner(variable0);
    variable2.forward(variable1);
    return {
        num_blocks: variable2.readNum(),
        num_entries: variable2.readNum(),
        key_index_decomp_len: _v2 && variable2.readNum(),
        key_index_comp_len: variable2.readNum(),
        key_blocks_len: variable2.readNum(),
        chksum: variable2.checksum_v2(),
        len: variable2.variable1() - variable1
    };
}",Read keyword summary at the begining of keyword section .,function 0 - > variable0 - > variable1,Read a block from the input stream .,0,Prediction2
"function addComment(type, value, start, end, loc) {
            var comment;
            assert(typeof start === 'number', 'Comment must have valid position');
    
            // Because the way the actual token is scanned, often the comments
            // (if any) are skipped twice during the lexical analysis.
            // Thus, we need to skip adding a comment if the comment array already
            // handled it.
            if (state.lastCommentStart >= start) {
                return;
            }
            state.lastCommentStart = start;
    
            comment = {
                type: type,
                value: value
            };
            if (extra.range) {
                comment.range = [start, end];
            }
            if (extra.loc) {
                comment.loc = loc;
            }
            extra.comments.push(comment);
            if (extra.attachComment) {
                extra.leadingComments.push(comment);
                extra.trailingComments.push(comment);
            }
        }","function func0(variable0, variable1, variable2, variable3, variable4) {
    var variable5;
    assert(typeof variable2 === 'number', 'Comment must have valid position');
    if (state.lastCommentStart >= variable2) {
        return;
    }
    state.lastCommentStart = variable2;
    variable5 = {
        variable0: variable0,
        variable1: variable1
    };
    if (extra.range) {
        variable5.range = [
            variable2,
            variable3
        ];
    }
    if (extra.variable4) {
        variable5.variable4 = variable4;
    }
    extra.comments.push(variable5);
    if (extra.attachComment) {
        extra.leadingComments.push(variable5);
        extra.trailingComments.push(variable5);
    }
}",7 . 4 Comments,Adds a comment to the current state .,Adds a comment to the comment stack .,1,Tie
"function setBrightness(addr, intensity) {
	    if(addr<0 || addr>=maxDevices)
			return;
	 	if (typeof intensity == 'undefined') return; 
		
		intensity = constrain(intensity, 0, 15); 
	    	
		spiTransfer(addr, OP_INTENSITY,intensity);

	}","function func0(variable0, variable1) {
    if (variable0 < 0 || variable0 >= maxDevices)
        return;
    if (typeof variable1 == 'undefined')
        return;
    variable1 = constrain(variable1, 0, 15);
    spiTransfer(variable0, OP_INTENSITY, variable1);
}",sets the brightness of the LEDs 0 to 15,Function 0 - > void,Set the current interrupt level for a device .,0,Prediction2
"function determineKesClass(options, Kes) {
  let KesOverride;

  // If there is a kes class specified, use that
  const kesClass = get(options, 'kesClass');
  if (kesClass) {
    KesOverride = loadKesOverride(process.cwd(), kesClass);
  }
  else {
    let kesFolder;

    // Check if there is kes.js in the kes folder
    if (options.kesFolder) {
      kesFolder = options.kesFolder;
    }
    else {
      kesFolder = path.join(process.cwd(), '.kes');
    }
    KesOverride = loadKesOverride(kesFolder);

    // If the first Kes override didn't load, check if there is
    // a kes.js in the template folder.
    if (!KesOverride) {
      const template = get(options, 'template', '/path/to/nowhere');
      kesFolder = path.join(process.cwd(), template);
      KesOverride = loadKesOverride(kesFolder);
    }
  }

  return KesOverride || Kes;
}","function func0(variable0, variable1) {
    let variable2;
    const variable3 = get(variable0, 'kesClass');
    if (variable3) {
        variable2 = loadKesOverride(process.cwd(), variable3);
    } else {
        let kesFolder;
        if (variable0.kesFolder) {
            kesFolder = variable0.kesFolder;
        } else {
            kesFolder = path.join(process.cwd(), '.kes');
        }
        variable2 = loadKesOverride(kesFolder);
        if (!variable2) {
            const template = get(variable0, 'template', '/path/to/nowhere');
            kesFolder = path.join(process.cwd(), template);
            variable2 = loadKesOverride(kesFolder);
        }
    }
    return variable2 || variable1;
}",Based on the information passed from the CLI by the commander module this function determines whether to use the default Kes class or use the override class provided by the user,Loads the . kes file from the config .,function 0 - > variable1 - > variable0 - > variable1,1,Prediction1
"function attemptRender(reporter, filename, src, resolve, reject, globals) {
	globals = globals || {};
	less.render(src, {
		// Specify search paths for @import directives
		paths : [
			""public/static/less""
		],
		// Specify a filename, for better error messages
		filename : filename,
		modifyVars : globals,
		compress : false
	}, function(e, css) {
		if (e) {
			if ((/^variable @(.+?) is undefined$/).test(e.message)) {
				// ignore undef variable
				globals[(/^variable @(.+?) is undefined$/).exec(e.message)[1]] = ""1"";
				attemptRender(reporter, filename, src, resolve, reject, globals);
				return;
			}
			reporter(""LESS"", filename, e.line, e.message);
			reject();
			return;
		}
		resolve({
			filename : filename,
			src : css.css || css
		});
	});
}","function func0(variable0, variable1, variable2, variable3, variable4, variable5) {
    variable5 = variable5 || {};
    less.render(variable2, {
        paths: ['public/static/less'],
        variable1: variable1,
        modifyVars: variable5,
        compress: false
    }, function (e, css) {
        if (e) {
            if (/^variable @(.+?) is undefined$/.test(e.message)) {
                variable5[/^variable @(.+?) is undefined$/.exec(e.message)[1]] = '1';
                func0(variable0, variable1, variable2, variable3, variable4, variable5);
                return;
            }
            variable0('LESS', variable1, e.line, e.message);
            variable4();
            return;
        }
        variable3({
            variable1: variable1,
            variable2: css.css || css
        });
    });
}",Attempt to validate the less file,Compile a less file .,Call variable0 with variable1 variable2 and variable3,1,Prediction1
"function killAttrs(model, attrs) {
  for (var i = 0; i < attrs.length; i++) {
    delete model[attrs[i]];
  }
}","function func0(variable0, variable1) {
    for (var i = 0; i < variable1.length; i++) {
        delete variable0[variable1[i]];
    }
}",remove attributes from a model,Function that deletes the values of variable0 from variable1,Remove a set of properties from an object .,0,Prediction2
"function publish(sChannelId, sEvent, oData) {
  const aSubscribers = copyArray(this.subscribers(sChannelId, sEvent));
  let oSubscriber;
  const nLenSubscribers = aSubscribers.length;
  if (nLenSubscribers === 0) {
    return false;
  }
  oData = preprocessorsPublishData(oData);
  while (!!(oSubscriber = aSubscribers.shift())) {
    _executeHandler(oSubscriber, oData, sChannelId, sEvent);
  }
  return true;
}","function func0(variable0, variable1, variable2) {
    const variable3 = copyArray(this.subscribers(variable0, variable1));
    let variable4;
    const variable5 = variable3.length;
    if (variable5 === 0) {
        return false;
    }
    variable2 = preprocessorsPublishData(variable2);
    while (!!(variable4 = variable3.shift())) {
        _executeHandler(variable4, variable2, variable0, variable1);
    }
    return true;
}",Publish the event in one channel .,Publishes data to all subscribers .,This function is the function that is called when the function is called .,1,Prediction1
"function requireBody(paramsList) {
  return function (req, res, next) {
    var errors = [];
    var status = 'ok';

    for (var i = 0; i < paramsList.length; i++) {
      var val = req.body[paramsList[i]];

      if (!val) {
        errors.push(`required parameter \`${paramsList[i]}\` not found.`);
        status = 'error';
      }
    }

    if (errors.length === 0) {
      next();
    } else {
      return res.status(400).json({
        errors: errors,
        status: status
      });
    }
  };
}","function func0(variable0) {
    return function (req, res, next) {
        var errors = [];
        var status = 'ok';
        for (var i = 0; i < variable0.length; i++) {
            var val = req.body[variable0[i]];
            if (!val) {
                errors.push(`required parameter \`${ variable0[i] }\` not found.`);
                status = 'error';
            }
        }
        if (errors.length === 0) {
            next();
        } else {
            return res.status(400).json({
                errors: errors,
                status: status
            });
        }
    };
}",Require the specified req . body parameters or else return a 400 with a descriptive JSON body,Returns a function that checks if a required parameter is present in req . body,Creates a middleware that checks for required parameters .,0,Prediction2
"function findSourceFile(fileName, isDefaultLib, refFile, refPos, refEnd) {
            if (filesByName.contains(fileName)) {
                // We've already looked for this file, use cached result
                return getSourceFileFromCache(fileName, /*useAbsolutePath*/ false);
            }
            var normalizedAbsolutePath = ts.getNormalizedAbsolutePath(fileName, host.getCurrentDirectory());
            if (filesByName.contains(normalizedAbsolutePath)) {
                var file_1 = getSourceFileFromCache(normalizedAbsolutePath, /*useAbsolutePath*/ true);
                // we don't have resolution for this relative file name but the match was found by absolute file name
                // store resolution for relative name as well
                filesByName.set(fileName, file_1);
                return file_1;
            }
            // We haven't looked for this file, do so now and cache result
            var file = host.getSourceFile(fileName, options.target, function (hostErrorMessage) {
                if (refFile !== undefined && refPos !== undefined && refEnd !== undefined) {
                    fileProcessingDiagnostics.add(ts.createFileDiagnostic(refFile, refPos, refEnd - refPos, ts.Diagnostics.Cannot_read_file_0_Colon_1, fileName, hostErrorMessage));
                }
                else {
                    fileProcessingDiagnostics.add(ts.createCompilerDiagnostic(ts.Diagnostics.Cannot_read_file_0_Colon_1, fileName, hostErrorMessage));
                }
            });
            filesByName.set(fileName, file);
            if (file) {
                skipDefaultLib = skipDefaultLib || file.hasNoDefaultLib;
                // Set the source file for normalized absolute path
                filesByName.set(normalizedAbsolutePath, file);
                var basePath = ts.getDirectoryPath(fileName);
                if (!options.noResolve) {
                    processReferencedFiles(file, basePath);
                }
                // always process imported modules to record module name resolutions
                processImportedModules(file, basePath);
                if (isDefaultLib) {
                    file.isDefaultLib = true;
                    files.unshift(file);
                }
                else {
                    files.push(file);
                }
            }
            return file;
            function getSourceFileFromCache(fileName, useAbsolutePath) {
                var file = filesByName.get(fileName);
                if (file && host.useCaseSensitiveFileNames()) {
                    var sourceFileName = useAbsolutePath ? ts.getNormalizedAbsolutePath(file.fileName, host.getCurrentDirectory()) : file.fileName;
                    if (ts.normalizeSlashes(fileName) !== ts.normalizeSlashes(sourceFileName)) {
                        if (refFile !== undefined && refPos !== undefined && refEnd !== undefined) {
                            fileProcessingDiagnostics.add(ts.createFileDiagnostic(refFile, refPos, refEnd - refPos, ts.Diagnostics.File_name_0_differs_from_already_included_file_name_1_only_in_casing, fileName, sourceFileName));
                        }
                        else {
                            fileProcessingDiagnostics.add(ts.createCompilerDiagnostic(ts.Diagnostics.File_name_0_differs_from_already_included_file_name_1_only_in_casing, fileName, sourceFileName));
                        }
                    }
                }
                return file;
            }
        }","function func0(variable0, variable1, variable2, variable3, variable4) {
    if (filesByName.contains(variable0)) {
        return func1(variable0, false);
    }
    var variable5 = ts.getNormalizedAbsolutePath(variable0, host.getCurrentDirectory());
    if (filesByName.contains(variable5)) {
        var file_1 = func1(variable5, true);
        filesByName.set(variable0, file_1);
        return file_1;
    }
    var variable6 = host.getSourceFile(variable0, options.target, function (hostErrorMessage) {
        if (variable2 !== undefined && variable3 !== undefined && variable4 !== undefined) {
            fileProcessingDiagnostics.add(ts.createFileDiagnostic(variable2, variable3, variable4 - variable3, ts.Diagnostics.Cannot_read_file_0_Colon_1, variable0, hostErrorMessage));
        } else {
            fileProcessingDiagnostics.add(ts.createCompilerDiagnostic(ts.Diagnostics.Cannot_read_file_0_Colon_1, variable0, hostErrorMessage));
        }
    });
    filesByName.set(variable0, variable6);
    if (variable6) {
        skipDefaultLib = skipDefaultLib || variable6.hasNoDefaultLib;
        filesByName.set(variable5, variable6);
        var basePath = ts.getDirectoryPath(variable0);
        if (!options.noResolve) {
            processReferencedFiles(variable6, basePath);
        }
        processImportedModules(variable6, basePath);
        if (variable1) {
            variable6.variable1 = true;
            files.unshift(variable6);
        } else {
            files.push(variable6);
        }
    }
    return variable6;
    function func1(variable0, variable7) {
        var variable6 = filesByName.get(variable0);
        if (variable6 && host.useCaseSensitiveFileNames()) {
            var sourceFileName = variable7 ? ts.getNormalizedAbsolutePath(variable6.variable0, host.getCurrentDirectory()) : variable6.variable0;
            if (ts.normalizeSlashes(variable0) !== ts.normalizeSlashes(sourceFileName)) {
                if (variable2 !== undefined && variable3 !== undefined && variable4 !== undefined) {
                    fileProcessingDiagnostics.add(ts.createFileDiagnostic(variable2, variable3, variable4 - variable3, ts.Diagnostics.File_name_0_differs_from_already_included_file_name_1_only_in_casing, variable0, sourceFileName));
                } else {
                    fileProcessingDiagnostics.add(ts.createCompilerDiagnostic(ts.Diagnostics.File_name_0_differs_from_already_included_file_name_1_only_in_casing, variable0, sourceFileName));
                }
            }
        }
        return variable6;
    }
}",Get source file from normalized fileName,Get a file from the current working directory .,This function returns a file or false if the file does not exist .,1,Prediction1
"function injectProxyHeaders(req, rule){
  // the HTTP host header is often needed by the target webserver config
  req.headers['host'] = rule.target.host + (rule.target.originalPort ? util.format(':%d', rule.target.originalPort) : '');
  // document that this request was proxied
  req.headers['via'] =  util.format('http://%s:%s', req.connection.address().address, req.connection.address().port);

  // inject any custom headers as configured
  config.headers.forEach(function(header) {
    var value = header.value,
        name = header.name;

    if(typeof(value) === 'function') {
      value = value.call(undefined, req);
    }

    if(typeof(value) !== 'string') {
      value = '';
    }

    if (typeof(name) === 'string') {
      req.headers[name.toLowerCase()] = value;
    }
  });

  injectAuthHeader(req);
}","function func0(variable0, variable1) {
    variable0.headers['host'] = variable1.target.host + (variable1.target.originalPort ? util.format(':%d', variable1.target.originalPort) : '');
    variable0.headers['via'] = util.format('http://%s:%s', variable0.connection.address().address, variable0.connection.address().port);
    config.headers.forEach(function (header) {
        var value = header.value, name = header.name;
        if (typeof value === 'function') {
            value = value.call(undefined, variable0);
        }
        if (typeof value !== 'string') {
            value = '';
        }
        if (typeof name === 'string') {
            variable0.headers[name.toLowerCase()] = value;
        }
    });
    injectAuthHeader(variable0);
}",inject any custom header values into a proxy request along with the x - forwarded - for x - forwarded - port and via headers,inject auth header to variable0,Injects the HTTP headers into the request .,0,Prediction2
"function suggest_tick_num(domain) {
	var MAX_TICKS = 10;
	var INTERVAL_BASE_VALS = [1, 2, 2.5, 5, 10, 25];
	var range = Math.abs(domain[0] - domain[1])
	var minimum = range / MAX_TICKS;
	var digits = Math.floor(range).toString().length;
	var multiplier = Math.pow(10, (digits - 2));

	var acceptable_intervals = reduce(INTERVAL_BASE_VALS, function(prev, curr) {
		var mult = curr * multiplier;

		if (mult >= minimum) {
			prev = prev.concat([mult]);
		}

		return prev;
	}, []);

	for (var i = 0; i < acceptable_intervals.length; i++) {
		var interval = acceptable_intervals[i]
		if(range % interval == 0) {
			return (range / interval) + 1
		}
	};

	return 11;
}","function func0(variable0) {
    var variable1 = 10;
    var variable2 = [
        1,
        2,
        2.5,
        5,
        10,
        25
    ];
    var variable3 = Math.abs(variable0[0] - variable0[1]);
    var variable4 = variable3 / variable1;
    var variable5 = Math.floor(variable3).function toString() { [native code] }().length;
    var variable6 = Math.pow(10, variable5 - 2);
    var variable7 = reduce(variable2, function (prev, curr) {
        var mult = curr * variable6;
        if (mult >= variable4) {
            prev = prev.concat([mult]);
        }
        return prev;
    }, []);
    for (var i = 0; i < variable7.length; i++) {
        var variable8 = variable7[i];
        if (variable3 % variable8 == 0) {
            return variable3 / variable8 + 1;
        }
    }
    ;
    return 11;
}",Given a the domain of a scale suggest the most numerous number of round number ticks that it cold be divided into while still containing values evenly divisible by 1 2 2 . 5 5 10 or 25 .,Returns the number of times a point is in the range [ 1 2 5 10 25 ) .,Returns the value of the function 0 .,1,Prediction1
"function extractStringLiteral() {
    var literal = [], enclosing = next();

    if(!(enclosing === '""' || enclosing === ""'"")) {
      throw ""Unexpected token at index "" + index +
        "" expected 'string' but found "" + enclosing;
    }

    while(hasNext() && peek() !== enclosing) {
      literal[literal.length] = next();
    }

    consume(); // ' or ""
    return literal.join('');
  }","function func0() {
    var variable0 = [], variable1 = next();
    if (!(variable1 === '""' || variable1 === '\'')) {
        throw 'Unexpected token at index ' + index + ' expected \'string\' but found ' + variable1;
    }
    while (hasNext() && peek() !== variable1) {
        variable0[variable0.length] = next();
    }
    consume();
    return variable0.join('');
}",String literals might start with or,Read a string from the input .,Parse variable 0,1,
"function getCompletionEntryDisplayName(name, target, performCharacterChecks) {
            if (!name) {
                return undefined;
            }
            name = ts.stripQuotes(name);
            if (!name) {
                return undefined;
            }
            // If the user entered name for the symbol was quoted, removing the quotes is not enough, as the name could be an
            // invalid identifier name. We need to check if whatever was inside the quotes is actually a valid identifier name.
            // e.g ""b a"" is valid quoted name but when we strip off the quotes, it is invalid.
            // We, thus, need to check if whatever was inside the quotes is actually a valid identifier name.
            if (performCharacterChecks) {
                if (!ts.isIdentifierStart(name.charCodeAt(0), target)) {
                    return undefined;
                }
                for (var i = 1, n = name.length; i < n; i++) {
                    if (!ts.isIdentifierPart(name.charCodeAt(i), target)) {
                        return undefined;
                    }
                }
            }
            return name;
        }","function func0(variable0, variable1, variable2) {
    if (!variable0) {
        return undefined;
    }
    variable0 = ts.stripQuotes(variable0);
    if (!variable0) {
        return undefined;
    }
    if (variable2) {
        if (!ts.isIdentifierStart(variable0.charCodeAt(0), variable1)) {
            return undefined;
        }
        for (var i = 1, n = variable0.length; i < n; i++) {
            if (!ts.isIdentifierPart(variable0.charCodeAt(i), variable1)) {
                return undefined;
            }
        }
    }
    return variable0;
}",Get a displayName from a given for completion list performing any necessary quotes stripping and checking whether the name is valid identifier name .,Check if variable0 starts with variable1 and is part of variable2,Removes quotes from a string .,0,Prediction2
"function isDeclarationName(name) {
        if (name.kind !== 69 /* Identifier */ && name.kind !== 9 /* StringLiteral */ && name.kind !== 8 /* NumericLiteral */) {
            return false;
        }
        var parent = name.parent;
        if (parent.kind === 226 /* ImportSpecifier */ || parent.kind === 230 /* ExportSpecifier */) {
            if (parent.propertyName) {
                return true;
            }
        }
        if (isDeclaration(parent)) {
            return parent.name === name;
        }
        return false;
    }","function func0(variable0) {
    if (variable0.kind !== 69 && variable0.kind !== 9 && variable0.kind !== 8) {
        return false;
    }
    var variable1 = variable0.variable1;
    if (variable1.kind === 226 || variable1.kind === 230) {
        if (variable1.propertyName) {
            return true;
        }
    }
    if (isDeclaration(variable1)) {
        return variable1.variable0 === variable0;
    }
    return false;
}",True if the given identifier string literal or number literal is the name of a declaration node,Checks if a node is a property declaration or not .,Returns true if variable0 is the same as variable1,1,Prediction1
"function startServer(options) {

  options = initOptions(options);

  var app = connect()
    , root = options.root
    , TEST = process.env.TEST
    , isSilent = options.silent || TEST;

  if (!isSilent) {
    app.use(log);
  }

  var smOpts = {};
  var smOptMap = {
    ftpl: 'template'
    , style: 'style'
  };
  Object.keys(smOptMap).forEach(function (key) {
    if (options[key] !== undefined) smOpts[smOptMap[key]] = options[key];
  });

  // serve markdown file
  app.use(serveMarkdown(root, smOpts));
  // common files
  app.use(serveStatic(root, {index: ['index.html']}));

  // serve directory
  app.use(serveIndex(root, {
    icon: true
    , template: options.dtpl
    , stylesheet: options.style
    , view: options.view
  }));

  debug('server run in ' + (process.env.TEST ? 'TEST' : 'PRODUCTION') + ' mode')
  if (!TEST) {
    app.listen(options.port);
    showSuccessInfo(options);
  }

  return app;
}","function func0(variable0) {
    variable0 = initOptions(variable0);
    var variable1 = connect(), variable2 = variable0.variable2, variable3 = process.env.variable3, variable4 = variable0.silent || variable3;
    if (!variable4) {
        variable1.use(log);
    }
    var variable5 = {};
    var variable6 = {
        ftpl: 'template',
        style: 'style'
    };
    Object.keys(variable6).forEach(function (key) {
        if (variable0[key] !== undefined)
            variable5[variable6[key]] = variable0[key];
    });
    variable1.use(serveMarkdown(variable2, variable5));
    variable1.use(serveStatic(variable2, { index: ['index.html'] }));
    variable1.use(serveIndex(variable2, {
        icon: true,
        template: variable0.dtpl,
        stylesheet: variable0.style,
        view: variable0.view
    }));
    debug('server run in ' + (process.env.variable3 ? 'TEST' : 'PRODUCTION') + ' mode');
    if (!variable3) {
        variable1.listen(variable0.port);
        showSuccessInfo(variable0);
    }
    return variable1;
}",start server with provided options,Start the server,Start the server .,0,Tie
"function toInteger(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      var remainder = value % 1;
      return value === value ? (remainder ? value - remainder : value) : 0;
    }","function func0(variable0) {
    if (!variable0) {
        return variable0 === 0 ? variable0 : 0;
    }
    variable0 = toNumber(variable0);
    if (variable0 === INFINITY || variable0 === -INFINITY) {
        var sign = variable0 < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
    }
    var variable1 = variable0 % 1;
    return variable0 === variable0 ? variable1 ? variable0 - variable1 : variable0 : 0;
}",Converts value to an integer .,Returns the result of the function,Converts a number to a positive integer .,0,Prediction2
"function hasValueSideModule(symbol) {
                    return ts.forEach(symbol.declarations, function (declaration) {
                        return declaration.kind === 218 /* ModuleDeclaration */ &&
                            ts.getModuleInstanceState(declaration) === 1 /* Instantiated */;
                    });
                }","function func0(variable0) {
    return ts.forEach(variable0.declarations, function (declaration) {
        return declaration.kind === 218 && ts.getModuleInstanceState(declaration) === 1;
    });
}",Returns true if there exists a module that introduces entities on the value side .,Returns true if the given node has a module state of 1 .,Returns true if variable0 is a function declaration .,1,Prediction1
"function requireRole(requiredRole) {
    return function(req, res, next) {
      if(!req.user) {
        return next(superloginError);
      }
      var roles = req.user.roles;
      if(!roles || !roles.length || roles.indexOf(requiredRole) === -1) {
        res.status(forbiddenError.status);
        res.json(forbiddenError);
      } else {
        next();
      }
    };
  }","function func0(variable0) {
    return function (req, res, next) {
        if (!req.user) {
            return next(superloginError);
        }
        var roles = req.user.roles;
        if (!roles || !roles.length || roles.indexOf(variable0) === -1) {
            res.status(forbiddenError.status);
            res.json(forbiddenError);
        } else {
            next();
        }
    };
}",Requires that the user have the specified role,Returns a middleware that checks if the current user has the given role .,Returns a function that checks if the user has not the given role,1,Prediction1
"function onNodeContextClick(targetNode, coords)
   {
      // Hides any existing node context menu.
      hideNodeContextMenu();

      if (typeof coords !== 'object') { coords = getElementCoords(this); }

      var popupmenu = $('#contextpopup .mdl-menu__container');

      var packageData = targetNode.packageData;

      var packageLink, packageType, scmLink, scmType;

      if (packageData)
      {
         if (packageData.packageLink)
         {
            packageLink = packageData.packageLink.link;
            packageType = packageData.packageLink.type;

            // Create proper name for package type.
            switch (packageType)
            {
               case 'npm':
                  packageType = 'NPM';
                  break;
            }
         }

         if (packageData.scmLink)
         {
            scmLink = packageData.scmLink.link;
            scmType = packageData.scmLink.type;

            // Create proper name for SCM type.
            switch (scmType)
            {
               case 'github':
                  scmType = 'Github';
                  break;
            }
         }
      }

      // Populate data for the context menu.
      popupmenu.find('li').each(function(index)
      {
         var liTarget = $(this);

         switch (index)
         {
            case 0:
               if (scmLink && scmType)
               {
                  liTarget.text('Open on ' + scmType);
                  liTarget.data('link', scmLink);
                  liTarget.removeClass('hidden');
               }
               else
               {
                  liTarget.addClass('hidden');
               }
               break;

            case 1:
               if (packageLink && packageType)
               {
                  liTarget.text('Open on ' + packageType);
                  liTarget.data('link', packageLink);
                  liTarget.removeClass('hidden');
               }
               else
               {
                  liTarget.addClass('hidden');
               }
               break;

            case 2:
               if (packageData && packageData.version)
               {
                  liTarget.text('Version: ' + packageData.version);
                  liTarget.removeClass('hidden');
               }
               else
               {
                  liTarget.addClass('hidden');
               }
               break;
         }
      });

      // Wrapping in a 100ms timeout allows MDL to draw animation when showing a context menu after one has been hidden.
      setTimeout(function()
      {
         // Assign new selected context node and highlight related nodes.
         selectedContextNode = targetNode;

         fadeRelatedNodes(selectedContextNode, true, nodes, links);

         // For MDL a programmatic click of the hidden context menu.
         var contextMenuButton = $(""#context-menu"");
         contextMenuButton.click();

         // Necessary to defer reposition of the context menu.
         setTimeout(function()
         {
            popupmenu.parent().css({ position: 'relative' });
            popupmenu.css({ left: coords.x, top: coords.y, position:'absolute' });
         }, 0);
      }, 100);
   }","function func0(variable0, variable1) {
    hideNodeContextMenu();
    if (typeof variable1 !== 'object') {
        variable1 = getElementCoords(this);
    }
    var variable2 = $('#contextpopup .mdl-menu__container');
    var variable3 = variable0.variable3;
    var variable4, variable5, variable6, variable7;
    if (variable3) {
        if (variable3.variable4) {
            variable4 = variable3.variable4.link;
            variable5 = variable3.variable4.type;
            switch (variable5) {
            case 'npm':
                variable5 = 'NPM';
                break;
            }
        }
        if (variable3.variable6) {
            variable6 = variable3.variable6.link;
            variable7 = variable3.variable6.type;
            switch (variable7) {
            case 'github':
                variable7 = 'Github';
                break;
            }
        }
    }
    variable2.find('li').each(function (index) {
        var liTarget = $(this);
        switch (index) {
        case 0:
            if (variable6 && variable7) {
                liTarget.text('Open on ' + variable7);
                liTarget.data('link', variable6);
                liTarget.removeClass('hidden');
            } else {
                liTarget.addClass('hidden');
            }
            break;
        case 1:
            if (variable4 && variable5) {
                liTarget.text('Open on ' + variable5);
                liTarget.data('link', variable4);
                liTarget.removeClass('hidden');
            } else {
                liTarget.addClass('hidden');
            }
            break;
        case 2:
            if (variable3 && variable3.version) {
                liTarget.text('Version: ' + variable3.version);
                liTarget.removeClass('hidden');
            } else {
                liTarget.addClass('hidden');
            }
            break;
        }
    });
    setTimeout(function () {
        selectedContextNode = variable0;
        fadeRelatedNodes(selectedContextNode, true, nodes, links);
        var contextMenuButton = $('#context-menu');
        contextMenuButton.click();
        setTimeout(function () {
            variable2.parent().css({ position: 'relative' });
            variable2.css({
                left: variable1.x,
                top: variable1.y,
                position: 'absolute'
            });
        }, 0);
    }, 100);
}",Shows the node context menu,Function to show the node context menu,Show the context menu .,0,Tie
"function startShell (db, program, files) {
  var repl = global.repl = term(db);

  createContext(db, repl, function () {
    var code = program.eval;

    if (code) {
      executeJS(code);
      if (!program.shell) {
        repl.emit('exit');
        return;
      }
    }

    if (files.length) {
      executeFiles(files);
      printCloseMsg();
    }

    repl.prompt = prompt;
    repl.displayPrompt()
  });
}","function func0(variable0, variable1, variable2) {
    var variable3 = global.variable3 = term(variable0);
    createContext(variable0, variable3, function () {
        var code = variable1.eval;
        if (code) {
            executeJS(code);
            if (!variable1.shell) {
                variable3.emit('exit');
                return;
            }
        }
        if (variable2.length) {
            executeFiles(variable2);
            printCloseMsg();
        }
        variable3.prompt = prompt;
        variable3.displayPrompt();
    });
}",Starts up a shell with the given context .,This function is the main entry point of the program . It is the main entry point of the program,Runs the given script in the given context .,0,Prediction2
"function jsonp(opts, cb) {
      opts = opts || {};

      if (typeof window === 'undefined') {
        // FUTURE: refactor node usage to live in here
        return cb();
      }

      var scriptEl = document.createElement('script');
      window._sailsIoJSConnect = function(response) {
        // In rare circumstances our script may have been vaporised.
        // Remove it, but only if it still exists
        // https://github.com/balderdashy/sails.io.js/issues/92
        if (scriptEl && scriptEl.parentNode) {
            scriptEl.parentNode.removeChild(scriptEl);
        }

        cb(response);
      };
      scriptEl.src = opts.url;
      document.getElementsByTagName('head')[0].appendChild(scriptEl);

    }","function func0(variable0, variable1) {
    variable0 = variable0 || {};
    if (typeof window === 'undefined') {
        return variable1();
    }
    var variable2 = document.createElement('script');
    window._sailsIoJSConnect = function (response) {
        if (variable2 && variable2.parentNode) {
            variable2.parentNode.removeChild(variable2);
        }
        variable1(response);
    };
    variable2.src = variable0.url;
    document.getElementsByTagName('head')[0].appendChild(variable2);
}",Send a JSONP request .,This function is used to create a script tag and call the variable1 function .,Creates a script element and adds it to the head .,0,Prediction2
"function expectKeyword(keyword, contextual) {
            var token = lex();
            if (token.type !== (contextual ? Token.Identifier : Token.Keyword) ||
                    token.value !== keyword) {
                throwUnexpected(token);
            }
        }","function func0(variable0, variable1) {
    var variable2 = lex();
    if (variable2.type !== (variable1 ? Token.Identifier : Token.Keyword) || variable2.value !== variable0) {
        throwUnexpected(variable2);
    }
}",Expect the next token to match the specified keyword . If not an exception will be thrown .,ECMA - 262 12 . 2,ECMA - 262 13 . 3 . 3,0,Tie
"function ShellStream(args){
    if(this instanceof ShellStream === false){
        return new ShellStream(args);
    }

    this._command = args;
    this._events = [];
    var self = this;
    // Create holders for events to be added
    streams.forEach(function(stream){
        self[stream] = {on:this.on, _events:[]};
    });
}","function func0(variable0) {
    if (this instanceof func0 === false) {
        return new func0(variable0);
    }
    this._command = variable0;
    this._events = [];
    var variable1 = this;
    streams.forEach(function (stream) {
        variable1[stream] = {
            on: this.on,
            _events: []
        };
    });
}",Main function for creating a shellstream,Creates a new CommandStream instance .,Initialize a new func0 .,1,Prediction1
"function Sprinter(username, password, repoSlugs, cache) {
    if (! username) {
        throw new Error('Missing username.');
    }
    if (! password) {
        throw new Error('Missing password.');
    }
    if (! repoSlugs) {
        throw new Error('Missing repositories.');
    }
    this.username = username;
    this.password = password;
    // Verify required configuration elements.
    this.repos = convertSlugsToObjects(repoSlugs);
    this.gh = new GitHubApi({
        version: '3.0.0'
      , timeout: 5000
    });
    this.gh.authenticate({
        type: 'basic'
      , username: this.username
      , password: this.password
    });
    this._CACHE = {};
    this.setCacheDuration(cache);
    this._setupCaching();
}","function func0(variable0, variable1, variable2, variable3) {
    if (!variable0) {
        throw new Error('Missing username.');
    }
    if (!variable1) {
        throw new Error('Missing password.');
    }
    if (!variable2) {
        throw new Error('Missing repositories.');
    }
    this.variable0 = variable0;
    this.variable1 = variable1;
    this.repos = convertSlugsToObjects(variable2);
    this.gh = new GitHubApi({
        version: '3.0.0',
        timeout: 5000
    });
    this.gh.authenticate({
        type: 'basic',
        variable0: this.variable0,
        variable1: this.variable1
    });
    this._CACHE = {};
    this.setCacheDuration(variable3);
    this._setupCaching();
}",Wrapper class around the GitHub API client providing some authentication convenience and additional utility functions for executing operations across the issue trackers of several repositories at once .,Creates a new instance of func0 .,Creates a new GitHub instance .,0,Prediction2
"function cleanup(done) {
  config = null;

  rules.forEach(function(rule){
    rule.done();
  });
  nock.cleanAll();

  handles.server.close();
  if (handles.gatewayServer !== undefined && handles.gatewayServer !== null) {
    handles.gatewayServer.close();
  }

  fs.unlinkSync(path.join(handles.filepath, '/index.txt'));

  handles = null;

  done();
}","function func0(variable0) {
    config = null;
    rules.forEach(function (rule) {
        rule.variable0();
    });
    nock.cleanAll();
    handles.server.close();
    if (handles.gatewayServer !== undefined && handles.gatewayServer !== null) {
        handles.gatewayServer.close();
    }
    fs.unlinkSync(path.join(handles.filepath, '/index.txt'));
    handles = null;
    variable0();
}",Teardown logic for the reusable test suites,Clean up all resources .,This function is called by nock to clean up all resources,1,Tie
"function getLoaderOptions(loaderPath, rule) {
  let multiRuleProp;

  if (isWebpack1) {
    multiRuleProp = 'loaders';
  } else if (rule.oneOf) {
    multiRuleProp = 'oneOf';
  } else {
    multiRuleProp = 'use';
  }

  const multiRule = typeof rule === 'object' && Array.isArray(rule[multiRuleProp]) ? rule[multiRuleProp] : null;
  let options;

  if (multiRule) {
    const rules = [].concat(...multiRule.map(r => (r.use || r)));
    options = rules.map(normalizeRule).find(r => loaderPath.includes(r.loader)).options;
  } else {
    options = normalizeRule(rule).options;
  }

  return options;
}","function func0(variable0, variable1) {
    let variable2;
    if (isWebpack1) {
        variable2 = 'loaders';
    } else if (variable1.oneOf) {
        variable2 = 'oneOf';
    } else {
        variable2 = 'use';
    }
    const variable3 = typeof variable1 === 'object' && Array.isArray(variable1[variable2]) ? variable1[variable2] : null;
    let variable4;
    if (variable3) {
        const rules = [].concat(...variable3.map(r => r.use || r));
        variable4 = rules.map(normalizeRule).find(r => variable0.includes(r.loader)).variable4;
    } else {
        variable4 = normalizeRule(variable1).variable4;
    }
    return variable4;
}",webpack 1 compat loader options finder . Returns normalized options .,Given a variable0 and variable1 return a variable4,Given a list of rules return the first rule that contains the given loader .,0,Prediction2
"function onDocumentMouseDown(event) {
    // Override default action
    event.preventDefault();
    // But not all of it
    container.focus();
    
    // Only do something if the panorama is loaded
    if (!loaded || !config.draggable) {
        return;
    }
    
    // Calculate mouse position relative to top left of viewer container
    var pos = mousePosition(event);

    // Log pitch / yaw of mouse click when debugging / placing hot spots
    if (config.hotSpotDebug) {
        var coords = mouseEventToCoords(event);
        console.log('Pitch: ' + coords[0] + ', Yaw: ' + coords[1] + ', Center Pitch: ' +
            config.pitch + ', Center Yaw: ' + config.yaw + ', HFOV: ' + config.hfov);
    }
    
    // Turn off auto-rotation if enabled
    stopAnimation();

    stopOrientation();
    config.roll = 0;

    speed.hfov = 0;

    isUserInteracting = true;
    latestInteraction = Date.now();
    
    onPointerDownPointerX = pos.x;
    onPointerDownPointerY = pos.y;
    
    onPointerDownYaw = config.yaw;
    onPointerDownPitch = config.pitch;
    
    uiContainer.classList.add('pnlm-grabbing');
    uiContainer.classList.remove('pnlm-grab');
    
    fireEvent('mousedown', event);
    animateInit();
}","function func0(variable0) {
    variable0.preventDefault();
    container.focus();
    if (!loaded || !config.draggable) {
        return;
    }
    var variable1 = mousePosition(variable0);
    if (config.hotSpotDebug) {
        var coords = mouseEventToCoords(variable0);
        console.log('Pitch: ' + coords[0] + ', Yaw: ' + coords[1] + ', Center Pitch: ' + config.pitch + ', Center Yaw: ' + config.yaw + ', HFOV: ' + config.hfov);
    }
    stopAnimation();
    stopOrientation();
    config.roll = 0;
    speed.hfov = 0;
    isUserInteracting = true;
    latestInteraction = Date.now();
    onPointerDownPointerX = variable1.x;
    onPointerDownPointerY = variable1.y;
    onPointerDownYaw = config.yaw;
    onPointerDownPitch = config.pitch;
    uiContainer.classList.add('pnlm-grabbing');
    uiContainer.classList.remove('pnlm-grab');
    fireEvent('mousedown', variable0);
    animateInit();
}",Event handler for mouse clicks . Initializes panning . Prints center and click location coordinates when hot spot debugging is enabled .,Handles the mouse down event .,mouse down event handler,1,Tie
"function indentIfOnDifferentLines(parent, node1, node2, valueToWriteWhenNotIndenting) {
                var realNodesAreOnDifferentLines = !ts.nodeIsSynthesized(parent) && !nodeEndIsOnSameLineAsNodeStart(node1, node2);
                // Always use a newline for synthesized code if the synthesizer desires it.
                var synthesizedNodeIsOnDifferentLine = synthesizedNodeStartsOnNewLine(node2);
                if (realNodesAreOnDifferentLines || synthesizedNodeIsOnDifferentLine) {
                    increaseIndent();
                    writeLine();
                    return true;
                }
                else {
                    if (valueToWriteWhenNotIndenting) {
                        write(valueToWriteWhenNotIndenting);
                    }
                    return false;
                }
            }","function func0(variable0, variable1, variable2, variable3) {
    var variable4 = !ts.nodeIsSynthesized(variable0) && !nodeEndIsOnSameLineAsNodeStart(variable1, variable2);
    var variable5 = synthesizedNodeStartsOnNewLine(variable2);
    if (variable4 || variable5) {
        increaseIndent();
        writeLine();
        return true;
    } else {
        if (variable3) {
            write(variable3);
        }
        return false;
    }
}",Returns true if the code was actually indented false otherwise . If the code is not indented an optional valueToWriteWhenNotIndenting will be emitted instead .,Checks if a node is a synthesized node .,Returns true if variable0 is not a synthesized node,1,Prediction1
"function _getPrimaryVersion(metadata) {
    var primaryVersion = null;
    for (var i = 0; i < metadata.versions.length; i++) {
        if (metadata.versions[i].status == STATUS_PRIMARY) {
            if (primaryVersion !== null) {
                throw new Error('Invalid key: multiple primary keys');
            }
            primaryVersion = metadata.versions[i].versionNumber;
        }
    }

    if (primaryVersion === null) {
        throw new Error('No primary key');
    }

    return primaryVersion;
}","function func0(variable0) {
    var variable1 = null;
    for (var i = 0; i < variable0.versions.length; i++) {
        if (variable0.versions[i].status == STATUS_PRIMARY) {
            if (variable1 !== null) {
                throw new Error('Invalid key: multiple primary keys');
            }
            variable1 = variable0.versions[i].versionNumber;
        }
    }
    if (variable1 === null) {
        throw new Error('No primary key');
    }
    return variable1;
}",find the primary version ; ensure we don t have more than one,Returns the version number of the primary key,Get the version number of the primary key .,0,Tie
"function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}","function func0(variable0, variable1) {
    if (variable0 === null || typeof variable0 === 'undefined') {
        return;
    }
    if (typeof variable0 !== 'object') {
        variable0 = [variable0];
    }
    if (isArray(variable0)) {
        for (var i = 0, l = variable0.length; i < l; i++) {
            variable1.call(null, variable0[i], i, variable0);
        }
    } else {
        for (var key in variable0) {
            if (Object.prototype.function hasOwnProperty() { [native code] }.call(variable0, key)) {
                variable1.call(null, variable0[key], key, variable0);
            }
        }
    }
}",Iterate over an Array or an Object invoking a function for each item .,Calls variable1 for each item in variable0,Iterate over an object .,0,Prediction2
"function _isDeclarativeViewsErrorType ( error ) {
        return error instanceof GenericError ||
               error instanceof TemplateError ||
               error instanceof CompilerError ||
               error instanceof CustomizationError ||
               error instanceof ConfigurationError;
    }","function func0(variable0) {
    return variable0 instanceof GenericError || variable0 instanceof TemplateError || variable0 instanceof CompilerError || variable0 instanceof CustomizationError || variable0 instanceof ConfigurationError;
}",Checks if an error belongs to the error types of Backbone . DeclarativeViews .,Checks if the given error is a generic error or a template error or a configuration error .,Returns true if variable0 is an error .,1,Prediction1
"function addEmails(callback,id,emails){
    if ((id===undefined) || (emails === undefined) || (! emails.length)) {
        return callback(returnError(""Empty email or book id""));
    }
    var data = {emails: serialize(emails)};
    sendRequest( 'addressbooks/' + id + '/emails', 'POST', data, true, callback );
}","function func0(variable0, variable1, variable2) {
    if (variable1 === undefined || variable2 === undefined || !variable2.length) {
        return variable0(returnError('Empty email or book id'));
    }
    var variable3 = { variable2: serialize(variable2) };
    sendRequest('addressbooks/' + variable1 + '/emails', 'POST', variable3, true, variable0);
}",Add new emails to address book,Send an email to a book,Add an email to a book,0,Prediction2
"function isIso8601DateTimeString(value) {
    var dateAndTimePieces = splitDateAndTime(value);
    var date = extractDateStructureFromDateAndTime(dateAndTimePieces);
    if (date) {
      var timeAndTimezone = extractTimeStructuresFromDateAndTime(dateAndTimePieces);
      var time = timeAndTimezone.time;
      var timezone = timeAndTimezone.timezone;

      return isValidDateStructure(date) &&
        isValidTimeStructure(time) &&
        (timezone === null || isValidTimeZoneStructure(timezone));
    } else {
      return false;
    }
  }","function func0(variable0) {
    var variable1 = splitDateAndTime(variable0);
    var variable2 = extractDateStructureFromDateAndTime(variable1);
    if (variable2) {
        var timeAndTimezone = extractTimeStructuresFromDateAndTime(variable1);
        var time = timeAndTimezone.time;
        var timezone = timeAndTimezone.timezone;
        return isValidDateStructure(variable2) && isValidTimeStructure(time) && (timezone === null || isValidTimeZoneStructure(timezone));
    } else {
        return false;
    }
}",Check that a given value is a valid ISO 8601 format date string with optional time and time zone components,Returns true if variable0 is a valid date and time,Determines if the given date is a valid date and time .,0,Prediction2
"function getPropertyDoppelganger(property, isRtl) {
  const convertedProperty = isRtl
    ? propertiesToConvert.rtl[property]
    : propertiesToConvert.ltr[property]

  return convertedProperty || property
}","function func0(variable0, variable1) {
    const variable2 = variable1 ? propertiesToConvert.rtl[variable0] : propertiesToConvert.ltr[variable0];
    return variable2 || variable0;
}",Logically gets the direction of the given property based on the flow direction context,Convert variable0 to variable1,Converts a property name to its equivalent value .,0,Prediction2
"function findParent(node, handle) {
  let current = node
  while (current) {
    if (handle(current)) {
      return current
    }
    current = current.parent
  }
}","function func0(variable0, variable1) {
    let variable2 = variable0;
    while (variable2) {
        if (variable1(variable2)) {
            return variable2;
        }
        variable2 = variable2.parent;
    }
}",start from node self,Find the first node in the tree that satisfies a predicate .,Returns the first variable that is equal to variable1 .,1,Prediction1
"function render (obj, def, html) {
  var i, nodes, handler, parser, element, elementPrototype

  // If given bindings with a root node, pick only the binding keys.
  if (Array.isArray(def)) def = def[1]

  // Generating the render function is processing intensive. Skip if possible.
  if (renderFnKey in def) return def[renderFnKey](obj)

  // Callback API looks weird. This is actually synchronous, not asynchronous.
  handler = new htmlParser.DomHandler(function (error, result) {
    if (error) throw error
    nodes = result
  }, handlerOptions)

  parser = new htmlParser.Parser(handler)
  parser.write(html)
  parser.end()

  for (i = nodes.length; i--;)
    if (nodes[i].type === 'tag') {
      element = nodes[i]
      break
    }

  if (!element) throw new Error('No element found!')

  elementPrototype = Object.getPrototypeOf(element)
  Element.prototype = elementPrototype
  Object.defineProperties(elementPrototype, elementExtension)

  processDefinition(def, nodes)
  def[renderFnKey] = makeRender(def, nodes)

  return def[renderFnKey](obj)
}","function func0(variable0, variable1, variable2) {
    var variable3, variable4, variable5, variable6, variable7, variable8;
    if (Array.isArray(variable1))
        variable1 = variable1[1];
    if (renderFnKey in variable1)
        return variable1[renderFnKey](variable0);
    variable5 = new htmlParser.DomHandler(function (error, result) {
        if (error)
            throw error;
        variable4 = result;
    }, handlerOptions);
    variable6 = new htmlParser.Parser(variable5);
    variable6.write(variable2);
    variable6.end();
    for (variable3 = variable4.length; variable3--;)
        if (variable4[variable3].type === 'tag') {
            variable7 = variable4[variable3];
            break;
        }
    if (!variable7)
        throw new Error('No element found!');
    variable8 = Object.getPrototypeOf(variable7);
    Element.prototype = variable8;
    Object.defineProperties(variable8, elementExtension);
    processDefinition(variable1, variable4);
    variable1[renderFnKey] = makeRender(variable1, variable4);
    return variable1[renderFnKey](variable0);
}",Internal function for rendering strings . The benchmark to beat is plain old string concatenation and for loops . Although this won t be faster it should work with more or less the same functionality as the DOM version .,This function is the function that is called when a template is rendered .,Render an HTML document .,0,Prediction2
"function betweenTags(editor, range) {
	if (equalCursorPos(range.anchor, range.head)) {
		const cursor = range.anchor;
		const mode = editor.getModeAt(cursor);

		if (mode.name === 'xml') {
			const left = editor.getTokenAt(cursor);
			const right = editor.getTokenAt(Object.assign({}, cursor, { ch: cursor.ch + 1 }));

			return left.type === 'tag bracket' && left.string === '>'
				&& right.type === 'tag bracket' && right.string === '</';
		}
	}
}","function func0(variable0, variable1) {
    if (equalCursorPos(variable1.anchor, variable1.head)) {
        const cursor = variable1.anchor;
        const mode = variable0.getModeAt(cursor);
        if (mode.name === 'xml') {
            const left = variable0.getTokenAt(cursor);
            const right = variable0.getTokenAt(Object.assign({}, cursor, { ch: cursor.ch + 1 }));
            return left.type === 'tag bracket' && left.string === '>' && right.type === 'tag bracket' && right.string === '</';
        }
    }
}",Check if given range is a single caret between tags,Returns true if variable0 is equal to variable1,Checks if the cursor is inside an XML tag .,0,Prediction2
"function toRequestQueue(request){
        if(cluster.isMaster){
            if(!Countly.app_key || !Countly.device_id){
                log(""app_key or device_id is missing"");
                return;
            }
            prepareRequest(request);
          
            if(requestQueue.length > queueSize){
                requestQueue.shift();
            }

            requestQueue.push(request);
            storeSet(""cly_queue"", requestQueue);
        }
        else{
            process.send({ cly: {cly_queue: request} });
        }
    }","function func0(variable0) {
    if (cluster.isMaster) {
        if (!Countly.app_key || !Countly.device_id) {
            log('app_key or device_id is missing');
            return;
        }
        prepareRequest(variable0);
        if (requestQueue.length > queueSize) {
            requestQueue.shift();
        }
        requestQueue.push(variable0);
        storeSet('cly_queue', requestQueue);
    } else {
        process.send({ cly: { cly_queue: variable0 } });
    }
}",insert request to queue,Send a request to the countly server .,This function will send a request to Countly,1,Prediction1
"function getShimVersion() {
		var version;

		try {
			version = navigator.plugins['Shockwave Flash'];
			version = version.description;
		} catch (e1) {
			try {
				version = new ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version');
			} catch (e2) {
				version = '0.0';
			}
		}
		version = version.match(/\d+/g);
		return parseFloat(version[0] + '.' + version[1]);
	}","function func0() {
    var variable0;
    try {
        variable0 = navigator.plugins['Shockwave Flash'];
        variable0 = variable0.description;
    } catch (e1) {
        try {
            variable0 = new ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version');
        } catch (e2) {
            variable0 = '0.0';
        }
    }
    variable0 = variable0.match(/\d+/g);
    return parseFloat(variable0[0] + '.' + variable0[1]);
}",Get the version of the Flash Player,Get the version of the current browser .,Get the version of Shockwave Flash,1,Prediction2
"function Imagesloader(opts){
	/**
     * @define {object} Collection of public methods.
     */
    var self = {};

    /**
     * @define {object} Options for the constructor 
     */
    var opts = opts || {};

    /**
	 * @define {object} A image loader object
	 */
	var imageloader = Imageloader();

    /**
     * @define {array} A holder for when an image is loaded
     */
	var imgs = [];

	/**
	 * @define {array} A holder for the image src that should be loaded
	 */
	var srcs = [];

	/**
	 * @define {object} A promise container for promises
	 */
	var def;

	/**
	 * Load a collection of images
	 * @example imageloader.load(['img1.jpg', 'img2.jpg', 'img3.jpg']).success(function(){ // Do something });
	 * @param {array} images A collection of img object or img.src (paths)
	 * @config {object} def Create a promise object
	 * @return {object} Return the promise object
	 */
	function load(images){
		def = Deferred();
		
		/**
		 * Check if the images is img objects or image src
		 * return string of src
		 */
		srcs = convertImagesToSrc(images);

		/**
		 * Loop through src's and load image
		 */
		for (var i = 0; i < srcs.length; i++) {
			imageloader.load(srcs[i])
			.success(function(img){

				/** call imageloaded a pass the img that is loaded */
				imageLoaded(img);
			})
			.error(function(msg){
				def.reject(msg + ' couldn\'t be loaded');
			});
		};
		return def.promise;
	}

	/**
	 * Image loaded checker
	 * @param {img} img The loaded image
	 */
	function imageLoaded(img){

		/** Notify the promise */
		def.notify(""notify"");

		/** Add the image to the imgs array */
		imgs.push(img);

		/** If the imgs array size is the same as the src's */
		if(imgs.length == srcs.length){

			/** First sort images, to have the same order as src's */
			sortImages();

			/** Resolve the promise with the images */
			def.resolve(imgs);
		}
	}

	/**
	 * Convert img to src
	 * @param {array} imgs A collection og img/img paths
	 * @config {array} src A temporally array for storing img path/src
	 * @return {array} Return an array of img src's
	 */
	function convertImagesToSrc(imgs){
		var src = [];
		for (var i = 0; i < imgs.length; i++) {

			/** If the img is an object (img) get the src  */
			if(typeof imgs[i]  == 'object'){
				src.push(imgs[i].src);
			}
		};

		/** If the src array is null return the original imgs array */
		return src.length ? src : imgs;
	}

	/**
	 * Sort images after the originally order
	 * @config {array} arr A temporally array for sorting images
	 */
	function sortImages(){
		var arr = [];
		/**
		 * Create a double loop
		 * And match the order of the srcs array
		 */
		for (var i = 0; i < srcs.length; i++) {
			for (var j = 0; j < imgs.length; j++) {
				var str = imgs[j].src.toString();
				var reg = new RegExp(srcs[i])
				/** If srcs matches the imgs add it the the new array */
				if(str.match(reg)) arr.push(imgs[j]);
			};
		};

		/** Override imgs array with the new sorted arr */
		imgs = arr;
	}

	/**
	 * Public methods
	 * @public {function}
	 */
	self.load = load;

	/**
	 * @return {object} Public methods
	 */
	return self;
}","function func0(variable0) {
    var variable1 = {};
    var variable0 = variable0 || {};
    var variable2 = Imageloader();
    var variable3 = [];
    var variable4 = [];
    var variable5;
    function func1(variable6) {
        variable5 = Deferred();
        variable4 = func3(variable6);
        for (var i = 0; i < variable4.length; i++) {
            variable2.func1(variable4[i]).success(function (variable7) {
                func2(variable7);
            }).error(function (msg) {
                variable5.reject(msg + ' couldn\'t be loaded');
            });
        }
        ;
        return variable5.promise;
    }
    function func2(variable7) {
        variable5.notify('notify');
        variable3.push(variable7);
        if (variable3.length == variable4.length) {
            func4();
            variable5.resolve(variable3);
        }
    }
    function func3(variable3) {
        var variable8 = [];
        for (var i = 0; i < variable3.length; i++) {
            if (typeof variable3[i] == 'object') {
                variable8.push(variable3[i].variable8);
            }
        }
        ;
        return variable8.length ? variable8 : variable3;
    }
    function func4() {
        var variable9 = [];
        for (var i = 0; i < variable4.length; i++) {
            for (var j = 0; j < variable3.length; j++) {
                var variable10 = variable3[j].variable8.function toString() { [native code] }();
                var variable11 = new RegExp(variable4[i]);
                if (variable10.match(variable11))
                    variable9.push(variable3[j]);
            }
            ;
        }
        ;
        variable3 = variable9;
    }
    variable1.func1 = func1;
    return variable1;
}",Image collection loader,Creates a new instance of Imageloader .,Returns a promise that resolves when all variables have been loaded,1,Prediction1
"function getReferencedExportContainer(node) {
            var symbol = getReferencedValueSymbol(node);
            if (symbol) {
                if (symbol.flags & 1048576 /* ExportValue */) {
                    // If we reference an exported entity within the same module declaration, then whether
                    // we prefix depends on the kind of entity. SymbolFlags.ExportHasLocal encompasses all the
                    // kinds that we do NOT prefix.
                    var exportSymbol = getMergedSymbol(symbol.exportSymbol);
                    if (exportSymbol.flags & 944 /* ExportHasLocal */) {
                        return undefined;
                    }
                    symbol = exportSymbol;
                }
                var parentSymbol = getParentOfSymbol(symbol);
                if (parentSymbol) {
                    if (parentSymbol.flags & 512 /* ValueModule */ && parentSymbol.valueDeclaration.kind === 248 /* SourceFile */) {
                        return parentSymbol.valueDeclaration;
                    }
                    for (var n = node.parent; n; n = n.parent) {
                        if ((n.kind === 218 /* ModuleDeclaration */ || n.kind === 217 /* EnumDeclaration */) && getSymbolOfNode(n) === parentSymbol) {
                            return n;
                        }
                    }
                }
            }
        }","function func0(variable0) {
    var variable1 = getReferencedValueSymbol(variable0);
    if (variable1) {
        if (variable1.flags & 1048576) {
            var exportSymbol = getMergedSymbol(variable1.exportSymbol);
            if (exportSymbol.flags & 944) {
                return undefined;
            }
            variable1 = exportSymbol;
        }
        var parentSymbol = getParentOfSymbol(variable1);
        if (parentSymbol) {
            if (parentSymbol.flags & 512 && parentSymbol.valueDeclaration.kind === 248) {
                return parentSymbol.valueDeclaration;
            }
            for (var n = variable0.parent; n; n = n.parent) {
                if ((n.kind === 218 || n.kind === 217) && getSymbolOfNode(n) === parentSymbol) {
                    return n;
                }
            }
        }
    }
}",Emitter support When resolved as an expression identifier if the given node references an exported entity return the declaration node of the exported entity s container . Otherwise return undefined .,Returns the value declaration of the given variable or undefined if it does not exist .,Returns the value declaration of variable0 .,1,Prediction1
"function getTypeFromTypeAliasReference(node, symbol) {
            var type = getDeclaredTypeOfSymbol(symbol);
            var links = getSymbolLinks(symbol);
            var typeParameters = links.typeParameters;
            if (typeParameters) {
                if (!node.typeArguments || node.typeArguments.length !== typeParameters.length) {
                    error(node, ts.Diagnostics.Generic_type_0_requires_1_type_argument_s, symbolToString(symbol), typeParameters.length);
                    return unknownType;
                }
                var typeArguments = ts.map(node.typeArguments, getTypeFromTypeNode);
                var id = getTypeListId(typeArguments);
                return links.instantiations[id] || (links.instantiations[id] = instantiateType(type, createTypeMapper(typeParameters, typeArguments)));
            }
            if (node.typeArguments) {
                error(node, ts.Diagnostics.Type_0_is_not_generic, symbolToString(symbol));
                return unknownType;
            }
            return type;
        }","function func0(variable0, variable1) {
    var variable2 = getDeclaredTypeOfSymbol(variable1);
    var variable3 = getSymbolLinks(variable1);
    var variable4 = variable3.variable4;
    if (variable4) {
        if (!variable0.typeArguments || variable0.typeArguments.length !== variable4.length) {
            error(variable0, ts.Diagnostics.Generic_type_0_requires_1_type_argument_s, symbolToString(variable1), variable4.length);
            return unknownType;
        }
        var typeArguments = ts.map(variable0.typeArguments, getTypeFromTypeNode);
        var id = getTypeListId(typeArguments);
        return variable3.instantiations[id] || (variable3.instantiations[id] = instantiateType(variable2, createTypeMapper(variable4, typeArguments)));
    }
    if (variable0.typeArguments) {
        error(variable0, ts.Diagnostics.Type_0_is_not_generic, symbolToString(variable1));
        return unknownType;
    }
    return variable2;
}",Get type from reference to type alias . When a type alias is generic the declared type of the type alias may include references to the type parameters of the alias . We replace those with the actual type arguments by instantiating the declared type . Instantiations are cached using the type identities of the type arguments as the key .,Returns the generic type of the given variable,Get the type of the given type node .,0,Prediction1
"function consumePair(stream, close, open) {
	const start = stream.pos;
	if (stream.eat(close)) {
		while (!stream.sol()) {
			if (stream.eat(open)) {
				return true;
			}

			stream.pos--;
		}
	}

	stream.pos = start;
	return false;
}","function func0(variable0, variable1, variable2) {
    const variable3 = variable0.pos;
    if (variable0.eat(variable1)) {
        while (!variable0.sol()) {
            if (variable0.eat(variable2)) {
                return true;
            }
            variable0.pos--;
        }
    }
    variable0.pos = variable3;
    return false;
}",Consumes full character pair if possible,returns true if variable0 . eat ( variable1 ),ECMA - 262 13 . 2 . 3,0,Prediction1
"function subDirectoriesWithFile(base, filename) {
  var result = [];
  if (fs.existsSync(base) && fs.statSync(base).isDirectory()) {
    if (fs.existsSync(path.join(base, filename))) {
      result.push(base);
    }
    fs.readdirSync(base)
      .forEach(function (subdir) {
        result.push.apply(result, subDirectoriesWithFile(path.join(base, subdir), filename));
      });
  }
  return result;
}","function func0(variable0, variable1) {
    var variable2 = [];
    if (fs.existsSync(variable0) && fs.statSync(variable0).isDirectory()) {
        if (fs.existsSync(path.join(variable0, variable1))) {
            variable2.push(variable0);
        }
        fs.readdirSync(variable0).forEach(function (subdir) {
            variable2.push.apply(variable2, func0(path.join(variable0, subdir), variable1));
        });
    }
    return variable2;
}",Find all subdirectories of the base recursively .,Get a list of files in a directory recursively .,Recursively walks the directory tree and returns a new array,1,Prediction1
"function getDefinedNames() {
  return Object.keys(primitives).concat(Object.keys(registry).map(function (type) {
    return registry[type].type;
  }));
}","function func0() {
    return Object.keys(primitives).concat(Object.keys(registry).map(function (type) {
        return registry[type].type;
    }));
}",Return all defined type names,Returns a list of all types in the registry .,Returns a list of all the types in the registry .,1,Tie
"function getDataTypeNameByCode(item) {
  if (!item || typeof item.code !== 'number') {
    throw new errors.ArgumentError('Invalid signature type definition');
  }
  const typeName = _dataTypesByCode[item.code];
  if (!typeName) {
    throw new errors.ArgumentError(util.format('Type with code %d not found', item.code));
  }
  if (!item.info) {
    return typeName;
  }
  if (util.isArray(item.info)) {
    return (typeName +
      '<' +
      item.info.map(function (t) {
        return getDataTypeNameByCode(t);
      }).join(', ') +
      '>');
  }
  if (typeof item.info.code === 'number') {
    return typeName + '<' + getDataTypeNameByCode(item.info) + '>';
  }
  return typeName;
}","function func0(variable0) {
    if (!variable0 || typeof variable0.code !== 'number') {
        throw new errors.ArgumentError('Invalid signature type definition');
    }
    const variable1 = _dataTypesByCode[variable0.code];
    if (!variable1) {
        throw new errors.ArgumentError(util.format('Type with code %d not found', variable0.code));
    }
    if (!variable0.info) {
        return variable1;
    }
    if (util.isArray(variable0.info)) {
        return variable1 + '<' + variable0.info.map(function (t) {
            return func0(t);
        }).join(', ') + '>';
    }
    if (typeof variable0.info.code === 'number') {
        return variable1 + '<' + func0(variable0.info) + '>';
    }
    return variable1;
}",Gets the data type name for a given type definition,Converts a signature type definition to a data type string .,Returns a string representation of a signature type .,1,Prediction1
"function closeAllInstances(registry = _registry) {
  const promises = [];
  const errors = [];
  while (registry.length > 0) {
    const knex = registry.pop();
    const destructionPromise = knex.destroy().catch(e => {
      errors.push({
        knex,
        cause: e
      });
    });
    promises.push(destructionPromise);
  }
  return Promise.all(promises).then(() => {
    return errors;
  });
}","function func0(registry = _registry) {
    const variable0 = [];
    const variable1 = [];
    while (registry.length > 0) {
        const variable2 = registry.pop();
        const variable3 = variable2.destroy().catch(e => {
            variable1.push({
                variable2,
                cause: e
            });
        });
        variable0.push(variable3);
    }
    return Promise.all(variable0).then(() => {
        return variable1;
    });
}",Attempts to close all registered knex instances,Destroy all objects in the registry .,Function that will destroy all variables in the registry,1,Tie
"function formatUnusedSnapshotsWarning(list, limit) {
  if (limit == 0) {
    return `Found ${list.length} unused snapshots`;
  }

  const prunedList = formatSnapshotList(list, limit);
  return `Found ${list.length} unused snapshots:\n${prunedList}`;
}","function func0(variable0, variable1) {
    if (variable1 == 0) {
        return `Found ${ variable0.length } unused snapshots`;
    }
    const variable2 = formatSnapshotList(variable0, variable1);
    return `Found ${ variable0.length } unused snapshots:\n${ variable2 }`;
}",Renders the message for unused snapshots warning,Format a list of unused snapshots .,Returns a string describing the number of unused snapshots .,1,Prediction2
"function Cloudinary(options) {
      var configuration;
      this.devicePixelRatioCache = {};
      this.responsiveConfig = {};
      this.responsiveResizeInitialized = false;
      configuration = new Configuration(options);
      this.config = function(newConfig, newValue) {
        return configuration.config(newConfig, newValue);
      };

      /**
       * Use \<meta\> tags in the document to configure this Cloudinary instance.
       * @return {Cloudinary} this for chaining
       */
      this.fromDocument = function() {
        configuration.fromDocument();
        return this;
      };

      /**
       * Use environment variables to configure this Cloudinary instance.
       * @return {Cloudinary} this for chaining
       */
      this.fromEnvironment = function() {
        configuration.fromEnvironment();
        return this;
      };

      /**
       * Initialize configuration.
       * @function Cloudinary#init
       * @see Configuration#init
       * @return {Cloudinary} this for chaining
       */
      this.init = function() {
        configuration.init();
        return this;
      };
    }","function func0(variable0) {
    var variable1;
    this.devicePixelRatioCache = {};
    this.responsiveConfig = {};
    this.responsiveResizeInitialized = false;
    variable1 = new Configuration(variable0);
    this.config = function (newConfig, newValue) {
        return variable1.config(newConfig, newValue);
    };
    this.fromDocument = function () {
        variable1.fromDocument();
        return this;
    };
    this.fromEnvironment = function () {
        variable1.fromEnvironment();
        return this;
    };
    this.init = function () {
        variable1.init();
        return this;
    };
}",Main Cloudinary class,Creates a new Configuration object .,Creates a new DevicePixelRatioCache instance .,0,Prediction1
"function getBookInfo(callback,id){
    if (id===undefined) {
        return callback(returnError('Empty book id'));
    }
    sendRequest( 'addressbooks/' + id, 'GET', {}, true, callback );
}","function func0(variable0, variable1) {
    if (variable1 === undefined) {
        return variable0(returnError('Empty book id'));
    }
    sendRequest('addressbooks/' + variable1, 'GET', {}, true, variable0);
}",Get information about book,Get a book,Get a book,0,Tie
"function GoogleLogin() {
    if (!(this instanceof GoogleLogin)) {
        return new GoogleLogin();
    }
    const self = this;

    /**
     * Based of https://github.com/tejado/pgoapi/blob/master/pgoapi/auth_google.py#L33
     */
    const GOOGLE_LOGIN_ANDROID_ID = '9774d56d682e549c';
    const GOOGLE_LOGIN_SERVICE =
        'audience:server:client_id:848232511240-7so421jotr2609rmqakceuu1luuq0ptb.apps.googleusercontent.com';
    const GOOGLE_LOGIN_APP = 'com.nianticlabs.pokemongo';
    const GOOGLE_LOGIN_CLIENT_SIG = '321187995bc7cdc2b5fc91b11a96e2baa8602c62';

    /**
     * Sets a proxy address to use for logins.
     * @param {string} proxy
     */
    this.setProxy = function(proxy) {
        google.setProxy(proxy);
    };

    /**
     * Performs the Google Login using Android Device and returns a Promise that will be resolved
     * with the auth token.
     * @param {string} username
     * @param {string} password
     * @return {Promise}
     */
    this.login = function(username, password) {
        return self.getMasterToken(username, password)
            .then(loginData => self.getToken(username, loginData))
            .then(authData => authData.Auth);
    };

    /**
     * Performs the Google login by skipping the password step and starting with the Master Token
     * instead. Returns a Promise that will be resolved with the auth token.
     * @param {string} username
     * @param {string} token
     * @return {Promise}
     */
    this.loginWithToken = function(username, token) {
        var loginData = {
            androidId: GOOGLE_LOGIN_ANDROID_ID,
            masterToken: token
        };
        return self.getToken(username, loginData).then(authData => authData.Auth);
    };

    /**
     * Initialize Google Login
     * @param {string} username
     * @param {string} password
     * @return {Promise}
     */
    this.getMasterToken = function(username, password) {
        return new Promise((resolve, reject) => {
            google.login(username, password, GOOGLE_LOGIN_ANDROID_ID, (err, data) => {
                if (err) {
                    if (err.response.statusCode === 403) {
                        reject(Error(
                            'Received code 403 from Google login. This could be because your account has ' +
                            '2-Step-Verification enabled. If that is the case, you need to generate an ' +
                            'App Password and use that instead of your regular password: ' +
                            'https://security.google.com/settings/security/apppasswords'
                        ));
                    } else {
                        reject(Error(err.response.statusCode + ': ' + err.response.statusMessage));
                    }
                    return;
                }

                resolve(data);
            });
        });
    };

    /**
     * Finalizes oAuth request using master token and resolved with the auth data
     * @private
     * @param {string} username
     * @param {string} loginData
     * @return {Promise}
     */
    this.getToken = function(username, loginData) {
        return new Promise((resolve, reject) => {
            google.oauth(username, loginData.masterToken, loginData.androidId,
                GOOGLE_LOGIN_SERVICE, GOOGLE_LOGIN_APP, GOOGLE_LOGIN_CLIENT_SIG, (err, data) => {
                    if (err) {
                        reject(Error(err.response.statusCode + ': ' + err.response.statusMessage));
                        return;
                    }

                    resolve(data);
                });
        });
    };
}","function func0() {
    if (!(this instanceof func0)) {
        return new func0();
    }
    const variable0 = this;
    const variable1 = '9774d56d682e549c';
    const variable2 = 'audience:server:client_id:848232511240-7so421jotr2609rmqakceuu1luuq0ptb.apps.googleusercontent.com';
    const variable3 = 'com.nianticlabs.pokemongo';
    const variable4 = '321187995bc7cdc2b5fc91b11a96e2baa8602c62';
    this.setProxy = function (proxy) {
        google.setProxy(proxy);
    };
    this.login = function (username, password) {
        return variable0.getMasterToken(username, password).then(loginData => variable0.getToken(username, loginData)).then(authData => authData.Auth);
    };
    this.loginWithToken = function (username, token) {
        var loginData = {
            androidId: variable1,
            masterToken: token
        };
        return variable0.getToken(username, loginData).then(authData => authData.Auth);
    };
    this.getMasterToken = function (username, password) {
        return new Promise((resolve, reject) => {
            google.login(username, password, variable1, (err, data) => {
                if (err) {
                    if (err.response.statusCode === 403) {
                        reject(Error('Received code 403 from Google login. This could be because your account has ' + '2-Step-Verification enabled. If that is the case, you need to generate an ' + 'App Password and use that instead of your regular password: ' + 'https://security.google.com/settings/security/apppasswords'));
                    } else {
                        reject(Error(err.response.statusCode + ': ' + err.response.statusMessage));
                    }
                    return;
                }
                resolve(data);
            });
        });
    };
    this.getToken = function (username, loginData) {
        return new Promise((resolve, reject) => {
            google.oauth(username, loginData.masterToken, loginData.androidId, variable2, variable3, variable4, (err, data) => {
                if (err) {
                    reject(Error(err.response.statusCode + ': ' + err.response.statusMessage));
                    return;
                }
                resolve(data);
            });
        });
    };
}",Google login client .,Creates a new GoogleUserContent instance .,Creates a new instance of func0 .,1,Prediction1
"function _delete(sModuleId) {
  const oModules = getModules();
  if (!isTypeOf(oModules[sModuleId], sNotDefined)) {
    delete oModules[sModuleId];
    return true;
  }
  return false;
}","function func0(variable0) {
    const variable1 = getModules();
    if (!isTypeOf(variable1[variable0], sNotDefined)) {
        delete variable1[variable0];
        return true;
    }
    return false;
}",_delete is a wrapper method that will call the native delete javascript function It s important to test the full code .,Remove a module from the registry .,Check if variable0 is defined,1,Prediction1
"function MacroAction(parent, definition) {
  var key;
  for (key in updateMixin) {
    this[key] = updateMixin[key];
  }
  MacroAction.super_.apply(this, arguments);
}","function func0(variable0, variable1) {
    var variable2;
    for (variable2 in updateMixin) {
        this[variable2] = updateMixin[variable2];
    }
    func0.super_.apply(this, arguments);
}",Initialize a new MacroAction with the given parent and definition .,Create a new instance of func0 .,Creates a new instance of the update class .,0,Prediction2
"function getReferencedNestedRedeclaration(node) {
            var symbol = getReferencedValueSymbol(node);
            return symbol && isNestedRedeclarationSymbol(symbol) ? symbol.valueDeclaration : undefined;
        }","function func0(variable0) {
    var variable1 = getReferencedValueSymbol(variable0);
    return variable1 && isNestedRedeclarationSymbol(variable1) ? variable1.valueDeclaration : undefined;
}",When resolved as an expression identifier if the given node references a nested block scoped entity with a name that hides an existing name return the declaration of that entity . Otherwise return undefined .,Returns the value declaration of variable0 .,Gets the value declaration of a referenced value .,0,Prediction2
"function DockerCmdManager(dockerdescPath) {
    dockerdescPath = dockerdescPath || './dockerdesc.json';

    if (!fs.existsSync(dockerdescPath)) {
        throw new Error(util.format('The path ""%s"" does not exists.', dockerdescPath));
    }
    /** @type {string} */
    this.dockerdescDir = path.dirname(dockerdescPath);

    var dockerdescPathStat = fs.statSync(dockerdescPath);
    if (dockerdescPathStat.isDirectory()) {
        this.dockerdescDir = dockerdescPath;
        dockerdescPath = path.join(dockerdescPath, 'dockerdesc.json');
    }
    /** @type {Dockerdesc} */
    var dockerdescContent = fs.readFileSync(dockerdescPath);
    try {
        this.dockerdesc = JSON.parse(dockerdescContent);
    } catch (err) {
        throw new Error('Problem in the dockerdesc.json file format.\n' + err.stack);
    }
}","function func0(variable0) {
    variable0 = variable0 || './dockerdesc.json';
    if (!fs.existsSync(variable0)) {
        throw new Error(util.format('The path ""%s"" does not exists.', variable0));
    }
    this.dockerdescDir = path.dirname(variable0);
    var variable1 = fs.statSync(variable0);
    if (variable1.isDirectory()) {
        this.dockerdescDir = variable0;
        variable0 = path.join(variable0, 'dockerdesc.json');
    }
    var variable2 = fs.readFileSync(variable0);
    try {
        this.dockerdesc = JSON.parse(variable2);
    } catch (err) {
        throw new Error('Problem in the dockerdesc.json file format.\n' + err.stack);
    }
}",This class manages the DockerCmd and handles dockerdesc . json,Parses the Dockerdesc . json file .,Create a new instance of dockerdesc . json,1,Prediction1
"function handleError (err, cb) {
  if (err) {
    if (cb) {
      return process.nextTick(function(){
        cb(err);
      });
    }
    console.error(err);
  }
}","function func0(variable0, variable1) {
    if (variable0) {
        if (variable1) {
            return process.nextTick(function () {
                variable1(variable0);
            });
        }
        console.error(variable0);
    }
}",Error reporting helper,Function to call variable0 with variable1,Logs an error to the console .,0,Prediction2
"function assignRolesToUsers(doc, oldDoc, accessAssignmentDefinition) {
    var users = resolveCollectionDefinition(doc, oldDoc, accessAssignmentDefinition.users);
    var roles = resolveRoleCollectionDefinition(doc, oldDoc, accessAssignmentDefinition.roles);

    role(users, roles);

    return {
      type: 'role',
      users: users,
      roles: roles
    };
  }","function func0(variable0, variable1, variable2) {
    var variable3 = resolveCollectionDefinition(variable0, variable1, variable2.variable3);
    var variable4 = resolveRoleCollectionDefinition(variable0, variable1, variable2.variable4);
    role(variable3, variable4);
    return {
        type: 'role',
        variable3: variable3,
        variable4: variable4
    };
}",Assigns role access to users,Resolve a role collection definition .,This function is used to create a function that can be used to create a function .,1,Prediction1
"function safeDelimiter(s, delimiter) {
  if (delimiter === undefined) {
    delimiter = '```';
  }
  while (s.indexOf(delimiter) !== -1) {
    delimiter += '`';
  }
  return delimiter;
}","function func0(variable0, variable1) {
    if (variable1 === undefined) {
        variable1 = '```';
    }
    while (variable0.indexOf(variable1) !== -1) {
        variable1 += '`';
    }
    return variable1;
}",safeDelimiter tries to find a safe delimiter by appending backticks until it finally finds it .,Returns a string that can be used as a function name .,Creates a string from an array of strings .,0,Prediction2
"function defineEventAttributeDescriptor(eventName) {
    return {
        get() {
            const listeners = getListeners(this);
            let node = listeners.get(eventName);
            while (node != null) {
                if (node.listenerType === ATTRIBUTE) {
                    return node.listener
                }
                node = node.next;
            }
            return null
        },

        set(listener) {
            if (typeof listener !== ""function"" && !isObject(listener)) {
                listener = null; // eslint-disable-line no-param-reassign
            }
            const listeners = getListeners(this);

            // Traverse to the tail while removing old value.
            let prev = null;
            let node = listeners.get(eventName);
            while (node != null) {
                if (node.listenerType === ATTRIBUTE) {
                    // Remove old value.
                    if (prev !== null) {
                        prev.next = node.next;
                    } else if (node.next !== null) {
                        listeners.set(eventName, node.next);
                    } else {
                        listeners.delete(eventName);
                    }
                } else {
                    prev = node;
                }

                node = node.next;
            }

            // Add new value.
            if (listener !== null) {
                const newNode = {
                    listener,
                    listenerType: ATTRIBUTE,
                    passive: false,
                    once: false,
                    next: null,
                };
                if (prev === null) {
                    listeners.set(eventName, newNode);
                } else {
                    prev.next = newNode;
                }
            }
        },
        configurable: true,
        enumerable: true,
    }
}","function func0(variable0) {
    return {
        get() {
            const listeners = getListeners(this);
            let node = listeners.get(variable0);
            while (node != null) {
                if (node.listenerType === ATTRIBUTE) {
                    return node.listener;
                }
                node = node.next;
            }
            return null;
        },
        set(listener) {
            if (typeof listener !== 'function' && !isObject(listener)) {
                listener = null;
            }
            const listeners = getListeners(this);
            let prev = null;
            let node = listeners.get(variable0);
            while (node != null) {
                if (node.listenerType === ATTRIBUTE) {
                    if (prev !== null) {
                        prev.next = node.next;
                    } else if (node.next !== null) {
                        listeners.set(variable0, node.next);
                    } else {
                        listeners.delete(variable0);
                    }
                } else {
                    prev = node;
                }
                node = node.next;
            }
            if (listener !== null) {
                const newNode = {
                    listener,
                    listenerType: ATTRIBUTE,
                    passive: false,
                    once: false,
                    next: null
                };
                if (prev === null) {
                    listeners.set(variable0, newNode);
                } else {
                    prev.next = newNode;
                }
            }
        },
        configurable: true,
        enumerable: true
    };
}",Get the property descriptor for the event attribute of a given event .,Creates a new attribute listener .,Creates a function that can be used to listen to an attribute .,1,Tie
"function getNextNode (index, activeNodes) {
  var i, j, nextNode

  for (i = index, j = activeNodes.length; i < j; i++)
    if (activeNodes[i]) {
      nextNode = activeNodes[i]
      break
    }

  return nextNode
}","function func0(variable0, variable1) {
    var variable2, variable3, variable4;
    for (variable2 = variable0, variable3 = variable1.length; variable2 < variable3; variable2++)
        if (variable1[variable2]) {
            variable4 = variable1[variable2];
            break;
        }
    return variable4;
}",Find next node in a potentially sparse array .,Returns the value of variable0 in variable1,Find the first element in an array .,0,Prediction2
"function diffArrays(arr1, arr2) {
        if (!Array.isArray(arr1) || !Array.isArray(arr2)) {
            return true;
        }
        if (arr1.length !== arr2.length) {
            return true;
        }
        for (var i = 0, len = arr1.length; i < len; i++) {
            if (arr1[i] !== arr2[i]) {
                return true;
            }
        }
        return false;
    }","function func0(variable0, variable1) {
    if (!Array.isArray(variable0) || !Array.isArray(variable1)) {
        return true;
    }
    if (variable0.length !== variable1.length) {
        return true;
    }
    for (var i = 0, len = variable0.length; i < len; i++) {
        if (variable0[i] !== variable1[i]) {
            return true;
        }
    }
    return false;
}",Diff two arrays .,Compares two arrays .,Returns true if variable0 is not equal to variable1,1,Prediction1
"function LevelUpArrayAdapter(name, db, serializer) {
  this.db = Sublevel(db);
  this.db = this.db.sublevel(name);
  this.name = name;
  this.serializer = serializer || {
    encode: function(val, callback) {
      callback(null, val);
    },
    decode: function(val, callback) {
      callback(null, val);
    }
  };
}","function func0(variable0, variable1, variable2) {
    this.variable1 = Sublevel(variable1);
    this.variable1 = this.variable1.sublevel(variable0);
    this.variable0 = variable0;
    this.variable2 = variable2 || {
        encode: function (val, callback) {
            callback(null, val);
        },
        decode: function (val, callback) {
            callback(null, val);
        }
    };
}",Level up adapter that looks like an array . Doesn t support inserts .,Creates a new Sublevel object .,Creates a new Sublevel function,1,Tie
"function configureLanProxy(options, config, done) {
  var portfinder = require('portfinder'),
      request = require('request'),
      credentials = config.proxy.gateway.auth,
      gatewayPort,
      expectedAuthorizationHeader,
      requestViaHeader,
      responseViaHeader;

  handles = handles || {};

  handles.gatewayServer = require('http').createServer(function (req, res) {
    expectedAuthorizationHeader = 'Basic ' + new Buffer(credentials).toString('base64');

    // HACK: node 0.12.x appears to inject a slash at the front
    //       of absolute URLs
    //       ex., GET http://www.example.com --> GET /http://www.exampel.com
    if (req.url.charAt(0) === '/') {
      req.url = req.url.substr(1);
    }

    // validate the proxy target
    if (req.url !== req.headers['x-forwarded-url']) {
        res.writeHead(500);
        res.end('{ ""error"": 500, ""message"": ""invalid proxy request, expected X-Forwarded-Url header ' + req.headers['x-forwarded-url'] + '"" }');
        return;
    }

    // validate the proxy credentials
    if (req.headers['authorization'] !== expectedAuthorizationHeader) {
      res.writeHead(401);
      res.end('{ ""error"": 401, ""message"": ""invalid proxy credentials, expected ' + expectedAuthorizationHeader + '"" }');
      return;
    }

    // determine if we are using a proxy that is not RFC compliant
    requestViaHeader = options.headers['Via'] ||
                        '127.0.0.1:' + handles.port;

    responseHostHeader = options.headers['Host'] ||
                        req.headers['host'];

    responseViaHeader = options.headers['Via'] ||
                        'http://localhost:' + gatewayPort;

    // validate the via header was injected and points to 127.0.0.1 in either ipv4 or ipv6 format
    if (req.headers['via'] === undefined || req.headers['via'] === null || req.headers['via'].indexOf(requestViaHeader) === -1) {
      res.writeHead(400);
      res.end('{ ""error"": 400, ""message"": ""invalid via header, expected ' + requestViaHeader + '"" }');
      return;
    }

    // strip the proxy credentials header
    req.headers['authorization'] = null;
    // simulate the behavior of x-forwarded-for with multiple proxies
    req.headers['x-forwarded-for'] = [req.headers['x-forwarded-for'], req.headers['via']].join(', ');
    // change the via header to this server
    req.headers['via'] = responseViaHeader;
    req.headers['host'] = responseHostHeader;

    var errorCallback = function errorCallback(err, repsonse, body) {
      if (err) {
        res.writeHead(500);
        res.end(JSON.stringify({ ""error"": 500, ""message"": err.message  }));
        return;
      }
    }

    request(req, errorCallback).pipe(res);
  });

  portfinder.getPort(function (err, port) {
    if (err) done(err);

    config.proxy.gateway.port = port;
    gatewayPort = port;

    handles.gatewayServer.listen(port, function() {
      done(null);
    });
  });
}","function func0(variable0, variable1, variable2) {
    var variable3 = require('portfinder'), variable4 = require('request'), variable5 = variable1.proxy.gateway.auth, variable6, variable7, variable8, variable9;
    handles = handles || {};
    handles.gatewayServer = require('http').createServer(function (req, res) {
        variable7 = 'Basic ' + new Buffer(variable5).function toString() { [native code] }('base64');
        if (req.url.charAt(0) === '/') {
            req.url = req.url.substr(1);
        }
        if (req.url !== req.headers['x-forwarded-url']) {
            res.writeHead(500);
            res.end('{ ""error"": 500, ""message"": ""invalid proxy request, expected X-Forwarded-Url header ' + req.headers['x-forwarded-url'] + '"" }');
            return;
        }
        if (req.headers['authorization'] !== variable7) {
            res.writeHead(401);
            res.end('{ ""error"": 401, ""message"": ""invalid proxy credentials, expected ' + variable7 + '"" }');
            return;
        }
        variable8 = variable0.headers['Via'] || '127.0.0.1:' + handles.port;
        responseHostHeader = variable0.headers['Host'] || req.headers['host'];
        variable9 = variable0.headers['Via'] || 'http://localhost:' + variable6;
        if (req.headers['via'] === undefined || req.headers['via'] === null || req.headers['via'].indexOf(variable8) === -1) {
            res.writeHead(400);
            res.end('{ ""error"": 400, ""message"": ""invalid via header, expected ' + variable8 + '"" }');
            return;
        }
        req.headers['authorization'] = null;
        req.headers['x-forwarded-for'] = [
            req.headers['x-forwarded-for'],
            req.headers['via']
        ].join(', ');
        req.headers['via'] = variable9;
        req.headers['host'] = responseHostHeader;
        var errorCallback = function errorCallback(err, repsonse, body) {
            if (err) {
                res.writeHead(500);
                res.end(JSON.stringify({
                    'error': 500,
                    'message': err.message
                }));
                return;
            }
        };
        variable4(req, errorCallback).pipe(res);
    });
    variable3.getPort(function (err, port) {
        if (err)
            variable2(err);
        variable1.proxy.gateway.port = port;
        variable6 = port;
        handles.gatewayServer.listen(port, function () {
            variable2(null);
        });
    });
}",Creates a simple LAN proxy using a vanilla HTTP server that verifies the state of the proxy credentials and the x - forwarded - url are correct .,This function is the main function of the proxy .,Creates a proxy server .,0,Prediction2
"function extractDescription (d) {
      if (!d) return;
      if (d === ""ERROR: No README data found!"") return;
      // the first block of text before the first heading
      // that isn't the first line heading
      d = d.trim().split('\n')
      for (var s = 0; d[s] && d[s].trim().match(/^(#|$)/); s ++);
      var l = d.length
      for (var e = s + 1; e < l && d[e].trim(); e ++);
      return d.slice(s, e).join(' ').trim()
    }","function func0(variable0) {
    if (!variable0)
        return;
    if (variable0 === 'ERROR: No README data found!')
        return;
    variable0 = variable0.trim().split('\n');
    for (var s = 0; variable0[s] && variable0[s].trim().match(/^(#|$)/); s++);
    var variable1 = variable0.length;
    for (var e = s + 1; e < variable1 && variable0[e].trim(); e++);
    return variable0.slice(s, e).join(' ').trim();
}",Extracts description from contents of a readme file in markdown format,function 0 - > string,Parse a README message .,0,Prediction2
"function URLSearchParamsPolyfill(search) {
        search = search || """";

        // support construct object with another URLSearchParams instance
        if (search instanceof URLSearchParams || search instanceof URLSearchParamsPolyfill) {
            search = search.toString();
        }
        this [__URLSearchParams__] = parseToDict(search);
    }","function func0(variable0) {
    variable0 = variable0 || '';
    if (variable0 instanceof URLSearchParams || variable0 instanceof func0) {
        variable0 = variable0.function toString() { [native code] }();
    }
    this[__URLSearchParams__] = parseToDict(variable0);
}",Make a URLSearchParams instance,Creates a new URLSearchParams object .,Properties of a URLSearchParams object .,0,Prediction1
"function checkElementTypeOfIterable(iterable, errorNode) {
            var elementType = getElementTypeOfIterable(iterable, errorNode);
            // Now even though we have extracted the iteratedType, we will have to validate that the type
            // passed in is actually an Iterable.
            if (errorNode && elementType) {
                checkTypeAssignableTo(iterable, createIterableType(elementType), errorNode);
            }
            return elementType || anyType;
        }","function func0(variable0, variable1) {
    var variable2 = getElementTypeOfIterable(variable0, variable1);
    if (variable1 && variable2) {
        checkTypeAssignableTo(variable0, createIterableType(variable2), variable1);
    }
    return variable2 || anyType;
}",When errorNode is undefined it means we should not report any errors .,Determines the type of an iterable .,Returns the type of the first element of variable0 and the second element of variable1,1,Prediction1
"function autoSetupTimeout(wait, vjs) {
  if (vjs) {
    videojs$2 = vjs;
  }

  window.setTimeout(autoSetup, wait);
}","function func0(variable0, variable1) {
    if (variable1) {
        videojs$2 = variable1;
    }
    window.setTimeout(autoSetup, variable0);
}",Wait until the page is loaded before running autoSetup . This will be called in autoSetup if hasLoaded returns false .,This function is called when the video is ready to use .,Setup the videojs module .,0,Prediction2
"function getNestedBottle(name) {
        var bottle;
        if (!this.nested[name]) {
            bottle = Bottle.pop();
            this.nested[name] = bottle;
            this.factory(name, function SubProviderFactory() {
                return bottle.container;
            });
        }
        return this.nested[name];
    }","function func0(variable0) {
    var variable1;
    if (!this.nested[variable0]) {
        variable1 = Bottle.pop();
        this.nested[variable0] = variable1;
        this.factory(variable0, function SubProviderFactory() {
            return variable1.container;
        });
    }
    return this.nested[variable0];
}",Get a nested bottle . Will set and return if not set .,Creates a sub - provider for the given variable,Creates a new sub provider instance .,0,Prediction2
"function cdvfileToAppData(uri) {
    var cdvFsRoot;

    if (uri.schemeName === 'cdvfile') {
        cdvFsRoot = uri.path.split('/')[1];
        if (cdvFsRoot === 'temporary') {
            return new Windows.Foundation.Uri(tempFolderAppDataBasePath, uri.path.split('/').slice(2).join('/'));
        } else if (cdvFsRoot === 'persistent') {
            return new Windows.Foundation.Uri(localFolderAppDataBasePath, uri.path.split('/').slice(2).join('/'));
        } else {
            throw new Error(cdvFsRoot + ' cdvfile root is not supported on Windows');
        }
    }

    return uri;
}","function func0(variable0) {
    var variable1;
    if (variable0.schemeName === 'cdvfile') {
        variable1 = variable0.path.split('/')[1];
        if (variable1 === 'temporary') {
            return new Windows.Foundation.Uri(tempFolderAppDataBasePath, variable0.path.split('/').slice(2).join('/'));
        } else if (variable1 === 'persistent') {
            return new Windows.Foundation.Uri(localFolderAppDataBasePath, variable0.path.split('/').slice(2).join('/'));
        } else {
            throw new Error(variable1 + ' cdvfile root is not supported on Windows');
        }
    }
    return variable0;
}",Converts cdvfile paths to ms - appdata path,Convert a Windows . Foundation . Uri to a Windows . Foundation . Uri,Returns a new Windows . Foundation . Uri object,1,Prediction2
"function getTypeFromClassOrInterfaceReference(node, symbol) {
            var type = getDeclaredTypeOfSymbol(symbol);
            var typeParameters = type.localTypeParameters;
            if (typeParameters) {
                if (!node.typeArguments || node.typeArguments.length !== typeParameters.length) {
                    error(node, ts.Diagnostics.Generic_type_0_requires_1_type_argument_s, typeToString(type, /*enclosingDeclaration*/ undefined, 1 /* WriteArrayAsGenericType */), typeParameters.length);
                    return unknownType;
                }
                // In a type reference, the outer type parameters of the referenced class or interface are automatically
                // supplied as type arguments and the type reference only specifies arguments for the local type parameters
                // of the class or interface.
                return createTypeReference(type, ts.concatenate(type.outerTypeParameters, ts.map(node.typeArguments, getTypeFromTypeNode)));
            }
            if (node.typeArguments) {
                error(node, ts.Diagnostics.Type_0_is_not_generic, typeToString(type));
                return unknownType;
            }
            return type;
        }","function func0(variable0, variable1) {
    var variable2 = getDeclaredTypeOfSymbol(variable1);
    var variable3 = variable2.localTypeParameters;
    if (variable3) {
        if (!variable0.typeArguments || variable0.typeArguments.length !== variable3.length) {
            error(variable0, ts.Diagnostics.Generic_type_0_requires_1_type_argument_s, typeToString(variable2, undefined, 1), variable3.length);
            return unknownType;
        }
        return createTypeReference(variable2, ts.concatenate(variable2.outerTypeParameters, ts.map(variable0.typeArguments, getTypeFromTypeNode)));
    }
    if (variable0.typeArguments) {
        error(variable0, ts.Diagnostics.Type_0_is_not_generic, typeToString(variable2));
        return unknownType;
    }
    return variable2;
}",Get type from reference to class or interface,Returns a reference to the type of the given variable .,Get the type of the given type node .,0,Prediction1
"function assert (t, m) {
  if (!t) {
    var err = new AssertionError(m)
    if (Error.captureStackTrace) Error.captureStackTrace(err, assert)
    throw err
  }
}","function func0(variable0, variable1) {
    if (!variable0) {
        var err = new AssertionError(variable1);
        if (Error.captureStackTrace)
            Error.captureStackTrace(err, func0);
        throw err;
    }
}",Minimal assert function,Asserts that a value is truthy .,Returns true if variable0 is true and false otherwise,1,Prediction1
"function clone (obj) {
  var newObj = {};

  // Return a new obj if no `obj` passed in
  if (!obj || typeof obj !== 'object' || Array.isArray(obj))
    return newObj;

  for (var prop in obj)
    newObj[prop] = obj[prop];
  return newObj;
}","function func0(variable0) {
    var variable1 = {};
    if (!variable0 || typeof variable0 !== 'object' || Array.isArray(variable0))
        return variable1;
    for (var prop in variable0)
        variable1[prop] = variable0[prop];
    return variable1;
}",Clones an object properties onto a new object,Convert an object to an object .,Returns a copy of variable0,1,Prediction2
"function shouldLog(testlevel, thresholdLevel) {
  var allowed = logLevelAllowedGranular(testlevel);
  if (allowed) {
    return true;
  }

  return logLevelAllowed(testlevel, thresholdLevel);
}","function func0(variable0, variable1) {
    var variable2 = logLevelAllowedGranular(variable0);
    if (variable2) {
        return true;
    }
    return logLevelAllowed(variable0, variable1);
}",Should I log?,Check if a log level is allowed .,Returns true if variable0 and variable1 are allowed,1,Prediction1
"function listAvailables(forceRefresh) {
	forceRefresh && (adaptersCache = []);

	if( adaptersCache.length ){
		return adaptersCache;
	}

	adaptersCache = fs.readdirSync(__dirname).filter(function(fileOrDirName){
		return isDir(__dirname + '/' + fileOrDirName);
	});
	return adaptersCache;
}","function func0(variable0) {
    variable0 && (adaptersCache = []);
    if (adaptersCache.length) {
        return adaptersCache;
    }
    adaptersCache = fs.readdirSync(__dirname).filter(function (fileOrDirName) {
        return isDir(__dirname + '/' + fileOrDirName);
    });
    return adaptersCache;
}",return a cached list of availables adapter unless forceRefresh is true,Returns an array of all available adapters .,Returns an array of adapters,1,Prediction1
"function remove (outputFile, done) {
    this.csFactory(function (_done) {
      this._remove(outputFile, done);
      _done();
    }.bind(this), L_WAIT)();
  }","function func0(variable0, variable1) {
    this.csFactory(function (_done) {
        this._remove(variable0, variable1);
        _done();
    }.bind(this), L_WAIT)();
}",Remove a file from the files array if it s there . Protected version .,remove variable0 and variable1,Remove an item from the cache,0,Prediction2
"function fixAngularPackage() {
    var packageJSON = {}, packageFile = '../../../package.json';
    if (fs.existsSync(packageFile)) {
        packageJSON = require(packageFile);
    } else {
        console.log(""This should not happen, your are missing your main package.json file!"");
        return;
    }

    if (!packageJSON.scripts) {
        packageJSON.scripts = {};
    }

    packageJSON.scripts[""start.ios""] = ""cd nativescript && tns emulate ios"";
    packageJSON.scripts[""start.livesync.ios""] = ""cd nativescript && tns livesync ios --emulator --watch"";
    packageJSON.scripts[""start.android""] = ""cd nativescript && tns emulate android"";
    packageJSON.scripts[""start.livesync.android""] = ""cd nativescript && tns livesync android --emulator --watch"";

    fs.writeFileSync(packageFile, JSON.stringify(packageJSON, null, 4), 'utf8');
}","function func0() {
    var variable0 = {}, variable1 = '../../../package.json';
    if (fs.existsSync(variable1)) {
        variable0 = require(variable1);
    } else {
        console.log('This should not happen, your are missing your main package.json file!');
        return;
    }
    if (!variable0.scripts) {
        variable0.scripts = {};
    }
    variable0.scripts['start.ios'] = 'cd nativescript && tns emulate ios';
    variable0.scripts['start.livesync.ios'] = 'cd nativescript && tns livesync ios --emulator --watch';
    variable0.scripts['start.android'] = 'cd nativescript && tns emulate android';
    variable0.scripts['start.livesync.android'] = 'cd nativescript && tns livesync android --emulator --watch';
    fs.writeFileSync(variable1, JSON.stringify(variable0, null, 4), 'utf8');
}",Fix the Angular Package,Create the main package . json file .,This function is the main function of the emulator,1,Prediction1
"function copy(val, key) {
  if (key === '__proto__') {
    return;
  }

  var obj = this[key];
  if (isObject(val) && isObject(obj)) {
    mixinDeep(obj, val);
  } else {
    this[key] = val;
  }
}","function func0(variable0, variable1) {
    if (variable1 === '__proto__') {
        return;
    }
    var variable2 = this[variable1];
    if (isObject(variable0) && isObject(variable2)) {
        mixinDeep(variable2, variable0);
    } else {
        this[variable1] = variable0;
    }
}",Copy properties from the source object to the target object .,Sets the value of a property on the object .,This is the function that will be called when a function is called .,1,Prediction1
"function GifCli(path, callback) {
    var frames = [];

    OneByOne([
        Tmp.dir
      , function (next, tmpDir) {
            var str = Fs.createReadStream(path)
              , isFinished = false
              , complete = []
              , i = 0
              ;

            str.on(""end"", function () {
                isFinished = true;
            });

            str.pipe(
                GifExplode(function (frame) {
                    Tmp.file({ postfix: "".gif"", }, function (err, cImg) {
                        (function (i, cImg) {
                            if (err) { return next(err); }
                            var wStr = Fs.createWriteStream(cImg);
                            frame.pipe(wStr);
                            complete[i] = false;
                            wStr.on(""close"", function () {
                                // TODO Allow passing options
                                ImageToAscii(cImg, function (err, asciified) {
                                    complete[i] = true;
                                    frames[i] = asciified || """";
                                    // TODO https://github.com/hughsk/gif-explode/issues/4
                                    //if (err) { return next(err); }
                                    if (!isFinished) { return; }
                                    if (!complete.filter(function (c) {
                                        return c !== true
                                    }).length) {
                                        next();
                                    }
                                });
                            });
                        })(i++, cImg);
                    });
                })
            );
        }
      , function (next) {
            frames = frames.filter(Boolean);
            next();
        }
    ], function (err) {
        if (err) { return callback(err); }
        callback(null, frames);
    });
}","function func0(variable0, variable1) {
    var variable2 = [];
    OneByOne([
        Tmp.dir,
        function (next, tmpDir) {
            var str = Fs.createReadStream(variable0), isFinished = false, complete = [], i = 0;
            str.on('end', function () {
                isFinished = true;
            });
            str.pipe(GifExplode(function (frame) {
                Tmp.file({ postfix: '.gif' }, function (err, cImg) {
                    (function (i, cImg) {
                        if (err) {
                            return next(err);
                        }
                        var wStr = Fs.createWriteStream(cImg);
                        frame.pipe(wStr);
                        complete[i] = false;
                        wStr.on('close', function () {
                            ImageToAscii(cImg, function (err, asciified) {
                                complete[i] = true;
                                variable2[i] = asciified || '';
                                if (!isFinished) {
                                    return;
                                }
                                if (!complete.filter(function (c) {
                                        return c !== true;
                                    }).length) {
                                    next();
                                }
                            });
                        });
                    }(i++, cImg));
                });
            }));
        },
        function (next) {
            variable2 = variable2.filter(Boolean);
            next();
        }
    ], function (err) {
        if (err) {
            return variable1(err);
        }
        variable1(null, variable2);
    });
}",GifCli Converts the gif file into ASCII frames .,This function is the main entry point of the function,Convert a GIF to ascii .,0,Prediction2
"function Resource(parent, definition) {
  this.parent = parent;
  this.definition = definition;

  // add mixins
  this._link = linkMixin;

  this._setup();
}","function func0(variable0, variable1) {
    this.variable0 = variable0;
    this.variable1 = variable1;
    this._link = linkMixin;
    this._setup();
}",Initialize a new Resource with the given parent and definition .,Creates a new func0 object .,Creates a new Link instance .,0,Tie
"function _copyCacheEntry ( cacheEntry ) {
        var copy = _.clone( cacheEntry );
        if ( _.isObject( copy.attributes ) ) copy.attributes = _.clone( copy.attributes );
        return copy;
    }","function func0(variable0) {
    var variable1 = _.clone(variable0);
    if (_.isObject(variable1.attributes))
        variable1.attributes = _.clone(variable1.attributes);
    return variable1;
}",Creates a copy of a cache entry and returns it . Protects the original cache entry from modification except for the _pluginData property which remains writable and can be accessed from the copy .,Returns a clone of variable0,Clone an object .,0,Prediction2
"function run(inch_args, options) {
  var callback = function(filename) {
      LocalInch.run(inch_args || ['suggest'], filename, noop);
    }

  if( options.dry_run ) callback = noop;
  retriever.run(PathExtractor.extractPaths(inch_args), callback);
}","function func0(variable0, variable1) {
    var variable2 = function (filename) {
        LocalInch.func0(variable0 || ['suggest'], filename, noop);
    };
    if (variable1.dry_run)
        variable2 = noop;
    retriever.func0(PathExtractor.extractPaths(variable0), variable2);
}",Runs a local version of Inch .,This is the function that gets called from the local inch .,Retrieve a list of files from the local inch .,0,Prediction2
"function getContextualTypeForInitializerExpression(node) {
            var declaration = node.parent;
            if (node === declaration.initializer) {
                if (declaration.type) {
                    return getTypeFromTypeNode(declaration.type);
                }
                if (declaration.kind === 138 /* Parameter */) {
                    var type = getContextuallyTypedParameterType(declaration);
                    if (type) {
                        return type;
                    }
                }
                if (ts.isBindingPattern(declaration.name)) {
                    return getTypeFromBindingPattern(declaration.name, /*includePatternInType*/ true);
                }
            }
            return undefined;
        }","function func0(variable0) {
    var variable1 = variable0.parent;
    if (variable0 === variable1.initializer) {
        if (variable1.type) {
            return getTypeFromTypeNode(variable1.type);
        }
        if (variable1.kind === 138) {
            var type = getContextuallyTypedParameterType(variable1);
            if (type) {
                return type;
            }
        }
        if (ts.isBindingPattern(variable1.name)) {
            return getTypeFromBindingPattern(variable1.name, true);
        }
    }
    return undefined;
}",In a variable parameter or property declaration with a type annotation the contextual type of an initializer expression is the type of the variable parameter or property . Otherwise in a parameter declaration of a contextually typed function expression the contextual type of an initializer expression is the contextual type of the parameter . Otherwise in a variable or parameter declaration with a binding pattern name the contextual type of an initializer expression is the type implied by the binding pattern .,Gets the type of a parameter .,Returns the type of the first argument of func0 .,1,Prediction1
"function brushUpdated(newSelection) {
        __.brushed = newSelection;
        events.brush.call(pc,__.brushed);
        pc.renderBrushed();
    }","function func0(variable0) {
    __.brushed = variable0;
    events.brush.call(pc, __.brushed);
    pc.renderBrushed();
}",This function can be used for live updates of brushes . That is during the specification of a brush this method can be called to update the view .,function 0 - > void,set the brushed state,0,Prediction2
"function insertSorted(arr, item, compareFunc) {
  if (arr.length === 0) {
    return arr.push(item);
  }
  let position = binarySearch(arr, item, compareFunc);
  if (position < 0) {
    position = ~position;
  }
  arr.splice(position, 0, item);
}","function func0(variable0, variable1, variable2) {
    if (variable0.length === 0) {
        return variable0.push(variable1);
    }
    let variable3 = binarySearch(variable0, variable1, variable2);
    if (variable3 < 0) {
        variable3 = ~variable3;
    }
    variable0.splice(variable3, 0, variable1);
}",Inserts the value in the position determined by its natural order determined by the compare func,Add variable1 to variable0,Insert a value into an array .,0,Prediction2
"function mkdir(path, silent) {
  if(!exists(path)) {
    fs.mkdirSync(path, 0755);
    if(!silent) console.log(terminal.cyan(pad('create : ')) + path);
  }
}","function func0(variable0, variable1) {
    if (!exists(variable0)) {
        fs.mkdirSync(variable0, 493);
        if (!variable1)
            console.log(terminal.cyan(pad('create : ')) + variable0);
    }
}",mkdir - p,Create a directory if it doesn t exist,Creates a directory if it doesn t exist .,0,Tie
"function activateSender(callback, senderEmail, code){
    if ((senderEmail===undefined)||(!senderEmail.length)||(code===undefined)||(!code.length)){
        return callback(returnError('Empty email or activation code'));
    }
    var data = {
        code: code
    }
    sendRequest( 'senders/' + senderEmail + '/code', 'POST', data, true, callback );
}","function func0(variable0, variable1, variable2) {
    if (variable1 === undefined || !variable1.length || variable2 === undefined || !variable2.length) {
        return variable0(returnError('Empty email or activation code'));
    }
    var variable3 = { variable2: variable2 };
    sendRequest('senders/' + variable1 + '/code', 'POST', variable3, true, variable0);
}",Activate sender using code,Send an email or activation code to an email sender,Send an email or activation code,1,Tie
"function processNodes (scope, node, def) {
  var document = scope ? scope.document : window.document
  var key, branch, result, mirrorNode, parent, marker, indices
  var i, j, treeWalker, orderedKeys

  result = def[templateKey]

  if (!result) {
    node = node.cloneNode(true)

    indices = []

    matchNodes(scope, node, def)

    orderedKeys = Object.keys(def).sort(function (a, b) {
      var nodeA = def[a][0][matchedNodeKey]
      var nodeB = def[b][0][matchedNodeKey]

      if (nodeA && nodeB)
        return nodeA.index - nodeB.index

      return 0
    })

    for (i = 0; i < orderedKeys.length; i++) {
      key = orderedKeys[i]
      branch = def[key]
      if (branch[isBoundToParentKey]) continue

      result = branch[0][matchedNodeKey]
      indices.push(result.index)
      mirrorNode = result.node
      parent = mirrorNode.parentNode

      // This value is memoized so that `appendChild` can be used instead of
      // `insertBefore`, which is a performance optimization.
      if (mirrorNode.nextElementSibling === null)
        branch[isMarkerLastKey] = true

      if (processNodes.useCommentNode) {
        marker = parent.insertBefore(
          document.createComment(' end ""' + key + '"" '), mirrorNode)
        parent.insertBefore(
          document.createComment(' begin ""' + key + '"" '), marker)
      }
      else marker = parent.insertBefore(
        document.createTextNode(''), mirrorNode)

      branch[markerKey] = marker

      parent.removeChild(mirrorNode)
    }

    Object.defineProperty(def, templateKey, {
      value: {
        node: node.cloneNode(true),
        indices: indices
      }
    })
  }
  else {
    node = result.node.cloneNode(true)
    indices = result.indices
    i = 0
    j = 0

    treeWalker = document.createTreeWalker(
      node, showAll, acceptNode, false)

    for (key in def) {
      branch = def[key]
      if (branch[isBoundToParentKey]) continue

      while (treeWalker.nextNode()) {
        if (i === indices[j]) {
          branch[markerKey] = treeWalker.currentNode
          i++
          break
        }
        i++
      }

      j++
    }
  }

  return node
}","function func0(variable0, variable1, variable2) {
    var variable3 = variable0 ? variable0.variable3 : window.variable3;
    var variable4, variable5, variable6, variable7, variable8, variable9, variable10;
    var variable11, variable12, variable13, variable14;
    variable6 = variable2[templateKey];
    if (!variable6) {
        variable1 = variable1.cloneNode(true);
        variable10 = [];
        matchNodes(variable0, variable1, variable2);
        variable14 = Object.keys(variable2).sort(function (a, b) {
            var nodeA = variable2[a][0][matchedNodeKey];
            var nodeB = variable2[b][0][matchedNodeKey];
            if (nodeA && nodeB)
                return nodeA.index - nodeB.index;
            return 0;
        });
        for (variable11 = 0; variable11 < variable14.length; variable11++) {
            variable4 = variable14[variable11];
            variable5 = variable2[variable4];
            if (variable5[isBoundToParentKey])
                continue;
            variable6 = variable5[0][matchedNodeKey];
            variable10.push(variable6.index);
            variable7 = variable6.variable1;
            variable8 = variable7.parentNode;
            if (variable7.nextElementSibling === null)
                variable5[isMarkerLastKey] = true;
            if (func0.useCommentNode) {
                variable9 = variable8.insertBefore(variable3.createComment(' end ""' + variable4 + '"" '), variable7);
                variable8.insertBefore(variable3.createComment(' begin ""' + variable4 + '"" '), variable9);
            } else
                variable9 = variable8.insertBefore(variable3.createTextNode(''), variable7);
            variable5[markerKey] = variable9;
            variable8.removeChild(variable7);
        }
        Object.defineProperty(variable2, templateKey, {
            value: {
                variable1: variable1.cloneNode(true),
                variable10: variable10
            }
        });
    } else {
        variable1 = variable6.variable1.cloneNode(true);
        variable10 = variable6.variable10;
        variable11 = 0;
        variable12 = 0;
        variable13 = variable3.createTreeWalker(variable1, showAll, acceptNode, false);
        for (variable4 in variable2) {
            variable5 = variable2[variable4];
            if (variable5[isBoundToParentKey])
                continue;
            while (variable13.nextNode()) {
                if (variable11 === variable10[variable12]) {
                    variable5[markerKey] = variable13.currentNode;
                    variable11++;
                    break;
                }
                variable11++;
            }
            variable12++;
        }
    }
    return variable1;
}",Internal function to remove bound nodes and replace them with markers .,This function is the main entry point of the function .,Match a template node against the current document .,0,Prediction2
"function validateObjectProperties(propertyValidators, allowUnknownProperties, ignoreInternalProperties) {
        var currentItemEntry = itemStack[itemStack.length - 1];
        var objectValue = currentItemEntry.itemValue;
        var oldObjectValue = currentItemEntry.oldItemValue;

        var supportedProperties = [ ];
        for (var propertyValidatorName in propertyValidators) {
          var validator = propertyValidators[propertyValidatorName];
          if (utils.isValueNullOrUndefined(validator) || utils.isValueNullOrUndefined(resolveItemConstraint(validator.type))) {
            // Skip over non-validator fields/properties
            continue;
          }

          var propertyValue = objectValue[propertyValidatorName];

          var oldPropertyValue;
          if (!utils.isValueNullOrUndefined(oldObjectValue)) {
            oldPropertyValue = oldObjectValue[propertyValidatorName];
          }

          supportedProperties.push(propertyValidatorName);

          itemStack.push({
            itemValue: propertyValue,
            oldItemValue: oldPropertyValue,
            itemName: propertyValidatorName
          });

          validateItemValue(validator);

          itemStack.pop();
        }

        // Verify there are no unsupported properties in the object
        if (!allowUnknownProperties) {
          for (var propertyName in objectValue) {
            if (ignoreInternalProperties && propertyName.indexOf('_') === 0) {
              // These properties are special cases that should always be allowed - generally only applied at the root
              // level of the document
              continue;
            }

            if (supportedProperties.indexOf(propertyName) < 0) {
              var objectPath = buildItemPath(itemStack);
              var fullPropertyPath = objectPath ? objectPath + '.' + propertyName : propertyName;
              validationErrors.push('property ""' + fullPropertyPath + '"" is not supported');
            }
          }
        }
      }","function func0(variable0, variable1, variable2) {
    var variable3 = itemStack[itemStack.length - 1];
    var variable4 = variable3.itemValue;
    var variable5 = variable3.oldItemValue;
    var variable6 = [];
    for (var propertyValidatorName in variable0) {
        var variable7 = variable0[propertyValidatorName];
        if (utils.isValueNullOrUndefined(variable7) || utils.isValueNullOrUndefined(resolveItemConstraint(variable7.type))) {
            continue;
        }
        var variable8 = variable4[propertyValidatorName];
        var variable9;
        if (!utils.isValueNullOrUndefined(variable5)) {
            variable9 = variable5[propertyValidatorName];
        }
        variable6.push(propertyValidatorName);
        itemStack.push({
            itemValue: variable8,
            oldItemValue: variable9,
            itemName: propertyValidatorName
        });
        validateItemValue(variable7);
        itemStack.pop();
    }
    if (!variable1) {
        for (var propertyName in variable4) {
            if (variable2 && propertyName.indexOf('_') === 0) {
                continue;
            }
            if (variable6.indexOf(propertyName) < 0) {
                var objectPath = buildItemPath(itemStack);
                var fullPropertyPath = objectPath ? objectPath + '.' + propertyName : propertyName;
                validationErrors.push('property ""' + fullPropertyPath + '"" is not supported');
            }
        }
    }
}",The following functions are nested within this function so they can share access to the doc oldDoc and validationErrors params and the attachmentReferenceValidators and itemStack variables,This function is called by validateItemValue to validate item values .,Validates the properties of an object .,0,Prediction2
"function onDocumentKeyUp(event) {
    // Record key pressed
    var keynumber = event.which || event.keycode;
    
    // Override default action for keys that are used
    if (config.capturedKeyNumbers.indexOf(keynumber) < 0)
        return;
    event.preventDefault();
    
    // Change key
    changeKey(keynumber, false);
}","function func0(variable0) {
    var variable1 = variable0.which || variable0.keycode;
    if (config.capturedKeyNumbers.indexOf(variable1) < 0)
        return;
    variable0.preventDefault();
    changeKey(variable1, false);
}",Event handler for key releases . Updates list of currently pressed keys .,Handle a keydown event .,This function is called when a key is pressed .,1,Prediction1
"function git(...args) {
  return new Promise((resolve, reject) => {
    const child = execFile('git', args, (err, stdout, stderr) => {
      if (err) {
        reject(err);
      } else {
        // Creating an object with named properties would probably be clearer
        // but this is compatible with thenify/promisify if we switch later.
        resolve([stdout, stderr]);
      }
    });
    child.stdin.end();
  });
}","function func0(...args) {
    return new Promise((resolve, reject) => {
        const child = execFile('git', args, (err, stdout, stderr) => {
            if (err) {
                reject(err);
            } else {
                resolve([
                    stdout,
                    stderr
                ]);
            }
        });
        child.stdin.end();
    });
}",Runs git with given arguments .,Execute a git command .,Executes git and returns a promise,1,Prediction2
"function Connection(endpoint, protocolVersion, options) {
  events.EventEmitter.call(this);
  this.setMaxListeners(0);

  if (!options) {
    throw new Error('options is not defined');
  }

  /**
   * Gets the ip and port of the server endpoint.
   * @type {String}
   */
  this.endpoint = endpoint;

  /**
   * Gets the friendly name of the host, used to identify the connection in log messages.
   * With direct connect, this is the address and port.
   * @type {String}
   */
  this.endpointFriendlyName = endpoint;

  if (!this.endpoint || this.endpoint.indexOf(':') < 0) {
    throw new Error('EndPoint must contain the ip address and port separated by : symbol');
  }

  const portSeparatorIndex = this.endpoint.lastIndexOf(':');
  this.address = this.endpoint.substr(0, portSeparatorIndex);
  this.port = this.endpoint.substr(portSeparatorIndex + 1);

  Object.defineProperty(this, ""options"", { value: options, enumerable: false, writable: false});

  if (protocolVersion === null) {
    // Set initial protocol version
    protocolVersion = types.protocolVersion.maxSupported;
    if (options.protocolOptions.maxVersion) {
      // User provided the protocol version
      protocolVersion = options.protocolOptions.maxVersion;
    }
    // Allow to check version using this connection instance
    this._checkingVersion = true;
  }

  this.protocolVersion = protocolVersion;
  /** @type {Object.<String, OperationState>} */
  this._operations = {};
  this._pendingWrites = [];
  this._preparing = {};

  /**
   * The timeout state for the idle request (heartbeat)
   */
  this._idleTimeout = null;
  this.timedOutOperations = 0;
  this._streamIds = new StreamIdStack(this.protocolVersion);
  this._metrics = options.metrics;

  this.encoder = new Encoder(protocolVersion, options);
  this.keyspace = null;
  this.emitDrain = false;
  /**
   * Determines if the socket is open and startup succeeded, whether the connection can be used to send requests / 
   * receive events
   */
  this.connected = false;
  /**
   * Determines if the socket can be considered as open
   */
  this.isSocketOpen = false;
}","function func0(variable0, variable1, variable2) {
    events.EventEmitter.call(this);
    this.setMaxListeners(0);
    if (!variable2) {
        throw new Error('options is not defined');
    }
    this.variable0 = variable0;
    this.endpointFriendlyName = variable0;
    if (!this.variable0 || this.variable0.indexOf(':') < 0) {
        throw new Error('EndPoint must contain the ip address and port separated by : symbol');
    }
    const variable3 = this.variable0.lastIndexOf(':');
    this.address = this.variable0.substr(0, variable3);
    this.port = this.variable0.substr(variable3 + 1);
    Object.defineProperty(this, 'options', {
        value: variable2,
        enumerable: false,
        writable: false
    });
    if (variable1 === null) {
        variable1 = types.variable1.maxSupported;
        if (variable2.protocolOptions.maxVersion) {
            variable1 = variable2.protocolOptions.maxVersion;
        }
        this._checkingVersion = true;
    }
    this.variable1 = variable1;
    this._operations = {};
    this._pendingWrites = [];
    this._preparing = {};
    this._idleTimeout = null;
    this.timedOutOperations = 0;
    this._streamIds = new StreamIdStack(this.variable1);
    this._metrics = variable2.metrics;
    this.encoder = new Encoder(variable1, variable2);
    this.keyspace = null;
    this.emitDrain = false;
    this.connected = false;
    this.isSocketOpen = false;
}",Represents a connection to a Cassandra node,Creates a new func0 instance .,Creates a new Endpoint .,0,Prediction2
"function openPopupWithPost(url, postData, name, options) {
    var form = document.createElement(""form"");
    var win;

    form.setAttribute(""method"", ""post"");
    form.setAttribute(""action"", url);
    form.setAttribute(""target"", name);

    Object.keys(postData).forEach(function addFormItem(key) {
        var input = document.createElement(""input"");
        input.type = ""hidden"";
        input.name = key;
        input.value = postData[key];
        form.appendChild(input);
    });

    document.body.appendChild(form);

    win = window.open(""/"", name, options);
    win.document.write(""Loading..."");

    form.submit();
    document.body.removeChild(form);

    return win;
}","function func0(variable0, variable1, variable2, variable3) {
    var variable4 = document.createElement('form');
    var variable5;
    variable4.setAttribute('method', 'post');
    variable4.setAttribute('action', variable0);
    variable4.setAttribute('target', variable2);
    Object.keys(variable1).forEach(function addFormItem(key) {
        var input = document.createElement('input');
        input.type = 'hidden';
        input.variable2 = key;
        input.value = variable1[key];
        variable4.appendChild(input);
    });
    document.body.appendChild(variable4);
    variable5 = window.open('/', variable2, variable3);
    variable5.document.write('Loading...');
    variable4.submit();
    document.body.removeChild(variable4);
    return variable5;
}",Create a form element add hidden inputs for all the post data and post it into a newly opened popup,Creates a form and opens it .,Create a form element and submit it,1,Prediction2
"function executeMigrationListeners(databaseName, oldVersion, newVersion,
    completionPromise) {
  for (let listener of migrationListeners) {
    try {
      listener(databaseName, oldVersion, newVersion, completionPromise)
    } catch (e) {
      console.warn(""A schema migration event listener threw an error"", e);
    }
  }
}","function func0(variable0, variable1, variable2, variable3) {
    for (let listener of migrationListeners) {
        try {
            listener(variable0, variable1, variable2, variable3);
        } catch (e) {
            console.warn('A schema migration event listener threw an error', e);
        }
    }
}",Executes the currently registered database schema migration listeners with the provided arguments .,Calls all migration listeners for a schema migration event .,Call all migration listeners,1,Prediction1
"async function indexExists(index) {
  try {
    const { nbHits } = await index.search();
    return nbHits > 0;
  } catch (e) {
    return false;
  }
}","async function func0(variable0) {
    try {
        const {nbHits} = await variable0.search();
        return nbHits > 0;
    } catch (e) {
        return false;
    }
}",Does an Algolia index exist already,Returns true if variable0 has hits,Checks if a document has a number of hits .,0,Prediction2
"function register ( type, lang, handler ) {
    if (Array.isArray(lang)) {
        lang.forEach((v) => store[type].langs[v] = handler);
        return;
    }
    store[type].langs[lang] = handler;
}","function func0(variable0, variable1, variable2) {
    if (Array.isArray(variable1)) {
        variable1.forEach(v => store[variable0].langs[v] = variable2);
        return;
    }
    store[variable0].langs[variable1] = variable2;
}",Register Loader of different Language,Adds a language to the store .,set variable0 to variable1 with variable2,1,Prediction1
"function stringify(content) {
  if (typeof content === 'string' && stringifiedRegexp.test(content)) {
    return content;
  }
  return JSON.stringify(content, null, 2);
}","function func0(variable0) {
    if (typeof variable0 === 'string' && stringifiedRegexp.test(variable0)) {
        return variable0;
    }
    return JSON.func0(variable0, null, 2);
}",If already stringified - return original content,If variable0 is a string return it .,Converts the given value to a string .,0,Prediction2
"function round_to_precision(num, precision, supress_thou_sep) {
	//zero should always be ""0""
	if (num === 0) return ""0"";

	var s = Math.round(num * Math.pow(10,precision)) / Math.pow(10,precision);
	s = s + """";

	s = s.split(""."");

	if (s.length == 1) {
		s[1] = """";
	}

	if (s[1].length < precision) {
		s[1] += Array(precision-s[1].length + 1).join(""0"");
	}

	if (!supress_thou_sep) {
		s[0] = d3.format("","")(parseInt(s[0]));
	}

	if (precision === 0) {
		return s[0];
	}

	return s.join(""."");
}","function func0(variable0, variable1, variable2) {
    if (variable0 === 0)
        return '0';
    var variable3 = Math.round(variable0 * Math.pow(10, variable1)) / Math.pow(10, variable1);
    variable3 = variable3 + '';
    variable3 = variable3.split('.');
    if (variable3.length == 1) {
        variable3[1] = '';
    }
    if (variable3[1].length < variable1) {
        variable3[1] += Array(variable1 - variable3[1].length + 1).join('0');
    }
    if (!variable2) {
        variable3[0] = d3.format(',')(parseInt(variable3[0]));
    }
    if (variable1 === 0) {
        return variable3[0];
    }
    return variable3.join('.');
}",round_to_precision Round a number to N decimal places,function 0 - > string,Convert a number to a string .,0,Prediction2
"function getSystemBucket(config) {
  let bucket = get(config, 'buckets.internal');
  if (bucket && typeof bucket === 'string') {
    return bucket;
  }

  bucket = get(config, 'system_bucket');
  if (bucket && typeof bucket === 'string') {
    return bucket;
  }
  return undefined;
}","function func0(variable0) {
    let variable1 = get(variable0, 'buckets.internal');
    if (variable1 && typeof variable1 === 'string') {
        return variable1;
    }
    variable1 = get(variable0, 'system_bucket');
    if (variable1 && typeof variable1 === 'string') {
        return variable1;
    }
    return undefined;
}",Discover and returns the system bucket used for deployment,Get bucket name from variable0,Get the bucket name from the config object .,0,Prediction2
"function getPlatformDetailsFromDir (dir, platformIfKnown) {
    var libDir = path.resolve(dir);
    var platform;
    var version;

    // console.log(""getPlatformDetailsFromDir : "", dir, platformIfKnown, libDir);

    try {
        var pkgPath = path.join(libDir, 'package.json');
        var pkg = cordova_util.requireNoCache(pkgPath);
        platform = module.exports.platformFromName(pkg.name);
        version = pkg.version;
    } catch (e) {
        return Promise.reject(new CordovaError('The provided path does not seem to contain a valid package.json or a valid Cordova platform: ' + libDir));
    }

    // platform does NOT have to exist in 'platforms', but it should have a name, and a version
    if (!version || !platform) {
        return Promise.reject(new CordovaError('The provided path does not seem to contain a ' +
            'Cordova platform: ' + libDir));
    }

    return Promise.resolve({
        libDir: libDir,
        platform: platform,
        version: version
    });
}","function func0(variable0, variable1) {
    var variable2 = path.resolve(variable0);
    var variable3;
    var variable4;
    try {
        var pkgPath = path.join(variable2, 'package.json');
        var pkg = cordova_util.requireNoCache(pkgPath);
        variable3 = module.exports.platformFromName(pkg.name);
        variable4 = pkg.variable4;
    } catch (e) {
        return Promise.reject(new CordovaError('The provided path does not seem to contain a valid package.json or a valid Cordova platform: ' + variable2));
    }
    if (!variable4 || !variable3) {
        return Promise.reject(new CordovaError('The provided path does not seem to contain a ' + 'Cordova platform: ' + variable2));
    }
    return Promise.resolve({
        variable2: variable2,
        variable3: variable3,
        variable4: variable4
    });
}",Gets platform details from a directory,Get the Cordova platform from the provided path .,Returns a promise that resolves to a Cordova platform object .,1,Prediction1
"function isIdentifierName(node) {
        var parent = node.parent;
        switch (parent.kind) {
            case 141 /* PropertyDeclaration */:
            case 140 /* PropertySignature */:
            case 143 /* MethodDeclaration */:
            case 142 /* MethodSignature */:
            case 145 /* GetAccessor */:
            case 146 /* SetAccessor */:
            case 247 /* EnumMember */:
            case 245 /* PropertyAssignment */:
            case 166 /* PropertyAccessExpression */:
                // Name in member declaration or property name in property access
                return parent.name === node;
            case 135 /* QualifiedName */:
                // Name on right hand side of dot in a type query
                if (parent.right === node) {
                    while (parent.kind === 135 /* QualifiedName */) {
                        parent = parent.parent;
                    }
                    return parent.kind === 154 /* TypeQuery */;
                }
                return false;
            case 163 /* BindingElement */:
            case 226 /* ImportSpecifier */:
                // Property name in binding element or import specifier
                return parent.propertyName === node;
            case 230 /* ExportSpecifier */:
                // Any name in an export specifier
                return true;
        }
        return false;
    }","function func0(variable0) {
    var variable1 = variable0.variable1;
    switch (variable1.kind) {
    case 141:
    case 140:
    case 143:
    case 142:
    case 145:
    case 146:
    case 247:
    case 245:
    case 166:
        return variable1.name === variable0;
    case 135:
        if (variable1.right === variable0) {
            while (variable1.kind === 135) {
                variable1 = variable1.variable1;
            }
            return variable1.kind === 154;
        }
        return false;
    case 163:
    case 226:
        return variable1.propertyName === variable0;
    case 230:
        return true;
    }
    return false;
}",Return true if the given identifier is classified as an IdentifierName,Checks if a node is a property or not .,Returns true if variable0 is a function,1,Prediction1
"function warning (message) {
  console.error()
  message.split('\n').forEach(function (line) {
    console.error('  warning: %s', line)
  })
  console.error()
}","function func0(variable0) {
    console.error();
    variable0.split('\n').forEach(function (line) {
        console.error('  warning: %s', line);
    });
    console.error();
}",Display a warning similar to how errors are displayed by commander .,function 0 - > console . error,Prints a warning message .,0,Prediction2
"function RangeParam(name, shortName, process) {
      if (process == null) {
        process = this.norm_range_value;
      }
      RangeParam.__super__.constructor.call(this, name, shortName, process);
    }","function func0(variable0, variable1, variable2) {
    if (variable2 == null) {
        variable2 = this.norm_range_value;
    }
    func0.__super__.function Object() { [native code] }.call(this, variable0, variable1, variable2);
}",A parameter that represents a range,Object constructor .,Object constructor .,0,Tie
"function replaceNode (value, previousValue, i) {
    var activeNode = activeNodes[i]
    var currentNode = node
    var returnValue

    // Cast values to null if undefined.
    if (value === void 0) value = null
    if (previousValue === void 0) previousValue = null

    // If value is null, just remove the Node.
    if (value === null) {
      removeNode(null, previousValue, i)
      return null
    }

    if (valueIsArray) keyPath.index = i
    else delete keyPath.index

    previousValues[i] = value

    if (definition) {
      if (activeNode) removeNode(value, previousValue, i)
      currentNode = processNodes(scope, node, definition)
      keyPath.target = valueIsArray ? value[i] : value
      bindKeys(scope, value, definition, currentNode, keyPath)
      if (mount) {
        keyPath.target = value
        mount(currentNode, value, null, keyPath)
      }
    }

    else {
      currentNode = activeNode || node.cloneNode(true)

      if (change) {
        returnValue = change(currentNode, value, previousValue, keyPath)
        if (returnValue !== void 0)
          changeValue(currentNode, returnValue, branch[replaceAttributeKey])
      }
      else {
        // Add default update behavior. Note that this event does not get
        // removed, since it is assumed that it will be garbage collected.
        if (previousValue === null &&
          ~updateTags.indexOf(currentNode.tagName))
          currentNode.addEventListener('input',
            updateChange(branch[replaceAttributeKey], keyPath, key))

        changeValue(currentNode, value, branch[replaceAttributeKey])
      }

      // Do not actually add an element to the DOM if it's only a change
      // between non-empty values.
      if (activeNode) return null
    }

    activeNodes[i] = currentNode

    return currentNode
  }","function func0(variable0, variable1, variable2) {
    var variable3 = activeNodes[variable2];
    var variable4 = node;
    var variable5;
    if (variable0 === void 0)
        variable0 = null;
    if (variable1 === void 0)
        variable1 = null;
    if (variable0 === null) {
        removeNode(null, variable1, variable2);
        return null;
    }
    if (valueIsArray)
        keyPath.index = variable2;
    else
        delete keyPath.index;
    previousValues[variable2] = variable0;
    if (definition) {
        if (variable3)
            removeNode(variable0, variable1, variable2);
        variable4 = processNodes(scope, node, definition);
        keyPath.target = valueIsArray ? variable0[variable2] : variable0;
        bindKeys(scope, variable0, definition, variable4, keyPath);
        if (mount) {
            keyPath.target = variable0;
            mount(variable4, variable0, null, keyPath);
        }
    } else {
        variable4 = variable3 || node.cloneNode(true);
        if (change) {
            variable5 = change(variable4, variable0, variable1, keyPath);
            if (variable5 !== void 0)
                changeValue(variable4, variable5, branch[replaceAttributeKey]);
        } else {
            if (variable1 === null && ~updateTags.indexOf(variable4.tagName))
                variable4.addEventListener('input', updateChange(branch[replaceAttributeKey], keyPath, key));
            changeValue(variable4, variable0, branch[replaceAttributeKey]);
        }
        if (variable3)
            return null;
    }
    activeNodes[variable2] = variable4;
    return variable4;
}",The return value of this function is a Node to be added otherwise null .,Update the value of the node at the given index .,This is the function that is called when a variable is inserted into the DOM . It is called when a variable is inserted .,1,Prediction1
"function restartBlink(cm) {
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursor.style.visibility = display.otherCursor.style.visibility = """";
    display.blinker = setInterval(function() {
      if (!display.cursor.offsetHeight) return;
      display.cursor.style.visibility = display.otherCursor.style.visibility = (on = !on) ? """" : ""hidden"";
    }, cm.options.cursorBlinkRate);
  }","function func0(variable0) {
    var variable1 = variable0.variable1;
    clearInterval(variable1.blinker);
    var variable2 = true;
    variable1.cursor.style.visibility = variable1.otherCursor.style.visibility = '';
    variable1.blinker = setInterval(function () {
        if (!variable1.cursor.offsetHeight)
            return;
        variable1.cursor.style.visibility = variable1.otherCursor.style.visibility = (variable2 = !variable2) ? '' : 'hidden';
    }, variable0.options.cursorBlinkRate);
}",Cursor - blinking,Sets the cursor visibility to hidden .,Function that sets the visibility of the cursor .,1,Prediction2
"function getReferencedImportDeclaration(node) {
            var symbol = getReferencedValueSymbol(node);
            return symbol && symbol.flags & 8388608 /* Alias */ ? getDeclarationOfAliasSymbol(symbol) : undefined;
        }","function func0(variable0) {
    var variable1 = getReferencedValueSymbol(variable0);
    return variable1 && variable1.flags & 8388608 ? getDeclarationOfAliasSymbol(variable1) : undefined;
}",When resolved as an expression identifier if the given node references an import return the declaration of that import . Otherwise return undefined .,Gets the declaration of the value of an alias .,Returns the declaration of the first alias of variable0 .,1,Prediction1
"function prepareQuery(thisStorage, filter, order) {
  order = normalizeKeyPath(order)
  
  let expectedSortingDirection = order[0].charAt(0) === ""!""
  let canSortingBeOptimized
  canSortingBeOptimized = canOptimizeSorting(expectedSortingDirection, order)
  
  let storages = new Map()
  storages.set(normalizeKeyPath(thisStorage.keyPath), {
    storage: thisStorage,
    score: 1 // traversing storage is faster than fetching records by index
  })
  
  for (let indexName of thisStorage.indexNames) {
    let index = thisStorage.getIndex(indexName)
    if (!index.multiEntry) {
      storages.set(normalizeKeyPath(index.keyPath), {
        storage: index,
        score: 0
      })
    }
  }
  
  let simplifiedOrderFieldPaths = simplifyOrderingFieldPaths(order)
  
  if (canSortingBeOptimized) {
    prepareSortingOptimization(storages, simplifiedOrderFieldPaths)
  }

  prepareFilteringOptimization(storages, filter)
  
  return chooseStorageForQuery(
    storages,
    order,
    simplifiedOrderFieldPaths,
    canSortingBeOptimized,
    expectedSortingDirection
  )
}","function func0(variable0, variable1, variable2) {
    variable2 = normalizeKeyPath(variable2);
    let variable3 = variable2[0].charAt(0) === '!';
    let variable4;
    variable4 = canOptimizeSorting(variable3, variable2);
    let variable5 = new Map();
    variable5.set(normalizeKeyPath(variable0.keyPath), {
        storage: variable0,
        score: 1
    });
    for (let indexName of variable0.indexNames) {
        let variable6 = variable0.getIndex(indexName);
        if (!variable6.multiEntry) {
            variable5.set(normalizeKeyPath(variable6.keyPath), {
                storage: variable6,
                score: 0
            });
        }
    }
    let variable7 = simplifyOrderingFieldPaths(variable2);
    if (variable4) {
        prepareSortingOptimization(variable5, variable7);
    }
    prepareFilteringOptimization(variable5, variable1);
    return chooseStorageForQuery(variable5, variable2, variable7, variable4, variable3);
}",Prepares the query that uses the specified filter and record order for execution on this storage .,Returns the storage for the given variable1 and variable2,Returns the appropriate storage for a query .,0,Prediction2
"function promiseWrapper(options, originalCallback, handler) {
  if (typeof originalCallback === 'function') {
    // Callback-based invocation
    handler.call(this, originalCallback);
    return undefined;
  }
  const factory = options.promiseFactory || defaultPromiseFactory;
  const self = this;
  return factory(function handlerWrapper(callback) {
    handler.call(self, callback);
  });
}","function func0(variable0, variable1, variable2) {
    if (typeof variable1 === 'function') {
        variable2.call(this, variable1);
        return undefined;
    }
    const variable3 = variable0.promiseFactory || defaultPromiseFactory;
    const variable4 = this;
    return variable3(function handlerWrapper(callback) {
        variable2.call(variable4, callback);
    });
}",Wraps the callback - based method . When no originalCallback is not defined it returns a Promise .,Returns a promise which will be resolved when the promise is resolved .,Creates a function that returns a promise that will be resolved when a promise is resolved .,0,Tie
"async function getNode(typeName, resolveInfo, context, condition, dbCall, options = {}) {
  // get the GraphQL type from the schema using the name
  const type = resolveInfo.schema._typeMap[typeName]
  assert(type, `Type ""${typeName}"" not found in your schema.`)
  assert(type._typeConfig.sqlTable, `joinMonster can't fetch a ${typeName} as a Node unless it has ""sqlTable"" tagged.`)

  // we need to determine what the WHERE function should be
  let where = buildWhereFunction(type, condition, options)

  // our getGraphQLType expects every requested field to be in the schema definition. ""node"" isn't a parent of whatever type we're getting, so we'll just wrap that type in an object that LOOKS that same as a hypothetical Node type
  const fakeParentNode = {
    _fields: {
      node: {
        type,
        name: type.name.toLowerCase(),
        where
      }
    }
  }
  const namespace = new AliasNamespace(options.minify)
  const sqlAST = {}
  const fieldNodes = resolveInfo.fieldNodes || resolveInfo.fieldASTs
  // uses the same underlying function as the main `joinMonster`
  queryAST.populateASTNode.call(resolveInfo, fieldNodes[0], fakeParentNode, sqlAST, namespace, 0, options, context)
  queryAST.pruneDuplicateSqlDeps(sqlAST, namespace)
  const { sql, shapeDefinition } = await compileSqlAST(sqlAST, context, options)
  const data = arrToConnection(await handleUserDbCall(dbCall, sql, sqlAST, shapeDefinition), sqlAST)
  await nextBatch(sqlAST, data, dbCall, context, options)
  if (!data) return data
  data.__type__ = type
  return data
}","async function func0(variable0, variable1, variable2, variable3, variable4, options = {}) {
    const variable5 = variable1.schema._typeMap[variable0];
    assert(variable5, `Type ""${ variable0 }"" not found in your schema.`);
    assert(variable5._typeConfig.sqlTable, `joinMonster can't fetch a ${ variable0 } as a Node unless it has ""sqlTable"" tagged.`);
    let variable6 = buildWhereFunction(variable5, variable3, options);
    const variable7 = {
        _fields: {
            node: {
                variable5,
                name: variable5.name.toLowerCase(),
                variable6
            }
        }
    };
    const variable8 = new AliasNamespace(options.minify);
    const variable9 = {};
    const variable10 = variable1.variable10 || variable1.fieldASTs;
    queryAST.populateASTNode.call(variable1, variable10[0], variable7, variable9, variable8, 0, options, variable2);
    queryAST.pruneDuplicateSqlDeps(variable9, variable8);
    const {sql, shapeDefinition} = await compileSqlAST(variable9, variable2, options);
    const variable11 = arrToConnection(await handleUserDbCall(variable4, sql, variable9, shapeDefinition), variable9);
    await nextBatch(variable9, variable11, variable4, variable2, options);
    if (!variable11)
        return variable11;
    variable11.__type__ = variable5;
    return variable11;
}",A helper for resolving the Node type in Relay .,This function is the main function of the joinMonster .,Fetch a joinMonster as a Node .,0,Prediction2
"function inlineResourcesFromString(content, urlResolver) {
  // Curry through the inlining functions.
  return [
    inlineTemplate,
    inlineStyle,
    removeModuleId
  ].reduce((content, fn) => fn(content, urlResolver), content);
}","function func0(variable0, variable1) {
    return [
        inlineTemplate,
        inlineStyle,
        removeModuleId
    ].reduce((variable0, fn) => fn(variable0, variable1), variable0);
}",Inline resources from a string content .,Returns a function that takes a variable0 and a variable1 and returns the result .,Apply inline templates inline styles and removeModuleId to an object .,0,Prediction2
"function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}","function func0(variable0, variable1) {
    var variable2 = variable0._x1 - variable0._x0;
    return variable2 ? (3 * (variable0._y1 - variable0._y0) / variable2 - variable1) / 2 : variable1;
}",Calculate a one - sided slope .,Get the distance between two points .,Calculates the distance between two variables .,1,Prediction1
"function parse(text, options) {
  options = Object.assign({}, { relaxed: true }, options);

  // relaxed implies not strict
  if (typeof options.relaxed === 'boolean') options.strict = !options.relaxed;
  if (typeof options.strict === 'boolean') options.relaxed = !options.strict;

  return JSON.parse(text, (key, value) => deserializeValue(this, key, value, options));
}","function func0(variable0, variable1) {
    variable1 = Object.assign({}, { relaxed: true }, variable1);
    if (typeof variable1.relaxed === 'boolean')
        variable1.strict = !variable1.relaxed;
    if (typeof variable1.strict === 'boolean')
        variable1.relaxed = !variable1.strict;
    return JSON.func0(variable0, (key, value) => deserializeValue(this, key, value, variable1));
}",Parse an Extended JSON string constructing the JavaScript value or object described by that string .,Deserialize a JSON object .,JSON . func0,1,Prediction1
"function ArrayParam(name, shortName, sep, process) {
      if (sep == null) {
        sep = '.';
      }
      this.sep = sep;
      ArrayParam.__super__.constructor.call(this, name, shortName, process);
    }","function func0(variable0, variable1, variable2, variable3) {
    if (variable2 == null) {
        variable2 = '.';
    }
    this.variable2 = variable2;
    func0.__super__.function Object() { [native code] }.call(this, variable0, variable1, variable3);
}",A parameter that represents an array,Object constructor .,Object constructor .,1,Tie
"function reflowText (text, width, gfm) {
      // Hard break was inserted by Renderer.prototype.br or is
      // <br /> when gfm is true
      var splitRe = gfm ? HARD_RETURN_GFM_RE : HARD_RETURN_RE,
          sections = text.split(splitRe),
          reflowed = [];
    
      sections.forEach(function (section) {
        var words = section.split(/[ \t\n]+/),
            column = 0,
            nextText = '';
    
        words.forEach(function (word) {
          var addOne = column != 0;
          if ((column + textLength(word) + addOne) > width) {
            nextText += '\n';
            column = 0;
          } else if (addOne) {
            nextText += "" "";
            column += 1;
          }
          nextText += word;
          column += textLength(word);
        });
        reflowed.push(nextText);
      });
      return reflowed.join('\n');
    }","function func0(variable0, variable1, variable2) {
    var variable3 = variable2 ? HARD_RETURN_GFM_RE : HARD_RETURN_RE, variable4 = variable0.split(variable3), variable5 = [];
    variable4.forEach(function (section) {
        var words = section.split(/[ \t\n]+/), column = 0, nextText = '';
        words.forEach(function (word) {
            var addOne = column != 0;
            if (column + textLength(word) + addOne > variable1) {
                nextText += '\n';
                column = 0;
            } else if (addOne) {
                nextText += ' ';
                column += 1;
            }
            nextText += word;
            column += textLength(word);
        });
        variable5.push(nextText);
    });
    return variable5.join('\n');
}",Munge \ n s and spaces in text so that the number of characters between \ n s is less than or equal to width .,Split a string into lines of text .,function 0 - > string,1,Prediction1
"function load(obj) {
  var name, root;
  root = typeof global !== ""undefined"" && global !== null ? global : this;
  for(name in obj) {
    if(obj.hasOwnProperty(name)) {
      root[name] = obj[name];
    }
  }
}","function func0(variable0) {
    var variable1, variable2;
    variable2 = typeof global !== 'undefined' && global !== null ? global : this;
    for (variable1 in variable0) {
        if (variable0.function hasOwnProperty() { [native code] }(variable1)) {
            variable2[variable1] = variable0[variable1];
        }
    }
}",load all the contract identifiers into the global scope,Copy properties from one object to another .,Copy variable0 to variable2,1,Prediction1
"function constructSelectEvent(nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  var doc = getEventTargetDocument(nativeEventTarget);

  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement$1);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement$1;

    accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}","function func0(variable0, variable1) {
    var variable2 = getEventTargetDocument(variable1);
    if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(variable2)) {
        return null;
    }
    var variable3 = getSelection(activeElement$1);
    if (!lastSelection || !shallowEqual(lastSelection, variable3)) {
        lastSelection = variable3;
        var syntheticEvent = SyntheticEvent.getPooled(eventTypes$3.select, activeElementInst$1, variable0, variable1);
        syntheticEvent.type = 'select';
        syntheticEvent.target = activeElement$1;
        accumulateTwoPhaseDispatches(syntheticEvent);
        return syntheticEvent;
    }
    return null;
}",Poll selection to see whether it s changed .,Creates a synthetic event for a select event .,The event handler for the select event .,1,Prediction1
"function alternative (options, { captcha: { url, siteKey } }) {
  // Here you do some magic with the siteKey provided by cloudscraper
  console.error('The url is ""' + url + '""');
  console.error('The site key is ""' + siteKey + '""');
  return Promise.reject(new Error('This is a dummy function'));
}","function func0(variable0, {
    captcha: {url, siteKey}
}) {
    console.error('The url is ""' + url + '""');
    console.error('The site key is ""' + siteKey + '""');
    return Promise.reject(new Error('This is a dummy function'));
}",An example handler with destructuring arguments,Return a promise that resolves to a promise .,This is a dummy function,1,Tie
"function planner(origin, dest, opts)  {

  var tasks   = new TaskPlanner();
  var cmds    = generateCommands(origin, dest);
  var state   = _.cloneDeep(origin);
  var result;

  opts = xtend(defaults, opts);

  assert(opts.mode === 'quick' || opts.mode === 'safe', 'unknown mode');

  tasks.addTask({ cmd: 'nop' }, {});
  generateDetachTasks(tasks, origin, opts);
  generateDetachTasks(tasks, dest, opts); // needed because of safe mode
  generateConfigureTasks(tasks, origin, dest, opts);

  _.forIn(state.topology.containers, function(container) {
    container.running = true;
    container.started = true;
    container.added = true;
  });

  _.forIn(dest.topology.containers, function(container) {
    var containers = state.topology.containers;

    if (!containers[container.id]) {
      containers[container.id] = {
        id: container.id,
        containedBy: container.containedBy,
        running: false,
        started: false,
        added: false
      };
    }
  });

  result = cmds.reduce(function(acc, cmd) {
    var plan = tasks.plan(state, cmd);
    if (!plan) {
      throw new Error('unable to generate ' + cmd.cmd + ' for id ' + cmd.id);
    }
    return acc.concat(plan);
  }, []).filter(function(cmd) {
    return cmd && cmd.cmd !== 'nop';
  });

  if (!opts.noLinkUnlinkRemove) {
    result = linkFilter(result);
  }

  return result;
}","function func0(variable0, variable1, variable2) {
    var variable3 = new TaskPlanner();
    var variable4 = generateCommands(variable0, variable1);
    var variable5 = _.cloneDeep(variable0);
    var variable6;
    variable2 = xtend(defaults, variable2);
    assert(variable2.mode === 'quick' || variable2.mode === 'safe', 'unknown mode');
    variable3.addTask({ cmd: 'nop' }, {});
    generateDetachTasks(variable3, variable0, variable2);
    generateDetachTasks(variable3, variable1, variable2);
    generateConfigureTasks(variable3, variable0, variable1, variable2);
    _.forIn(variable5.topology.containers, function (container) {
        container.running = true;
        container.started = true;
        container.added = true;
    });
    _.forIn(variable1.topology.containers, function (container) {
        var containers = variable5.topology.containers;
        if (!containers[container.id]) {
            containers[container.id] = {
                id: container.id,
                containedBy: container.containedBy,
                running: false,
                started: false,
                added: false
            };
        }
    });
    variable6 = variable4.reduce(function (acc, cmd) {
        var plan = variable3.plan(variable5, cmd);
        if (!plan) {
            throw new Error('unable to generate ' + cmd.cmd + ' for id ' + cmd.id);
        }
        return acc.concat(plan);
    }, []).filter(function (cmd) {
        return cmd && cmd.cmd !== 'nop';
    });
    if (!variable2.noLinkUnlinkRemove) {
        variable6 = linkFilter(variable6);
    }
    return variable6;
}",Creates a new planner,This function is the main entry point of the function . It is the main entry point of the function .,Creates a new TaskPlanner instance .,0,Prediction2
"function score(backend, errorBasis) {
    if (typeof errorBasis !== ""number"" && !errorBasis)
        errorBasis = Date.now();
    const timeSinceError = (errorBasis - backend.lastError);
    const statuses = backend.statuses;
    const timeWeight = (backend.lastError === 0 && 0) ||
        ((timeSinceError < 1000) && 1) ||
        ((timeSinceError < 3000) && 0.8) ||
        ((timeSinceError < 5000) && 0.3) ||
        ((timeSinceError < 10000) && 0.1) ||
        0;
    if (statuses.length == 0)
        return 0;
    let requests = 0;
    let errors = 0;
    for (let i = 0; i < statuses.length; i++) {
        const status = statuses[i];
        if (status && !isNaN(status)) {
            requests += 1;
            if (status >= 500 && status < 600) {
                errors += 1;
            }
        }
    }
    const score = (1 - (timeWeight * (errors / requests)));
    backend.healthScore = score;
    backend.scoredRequestCount = backend.requestCount;
    return score;
}","function func0(variable0, variable1) {
    if (typeof variable1 !== 'number' && !variable1)
        variable1 = Date.now();
    const variable2 = variable1 - variable0.lastError;
    const variable3 = variable0.variable3;
    const variable4 = variable0.lastError === 0 && 0 || variable2 < 1000 && 1 || variable2 < 3000 && 0.8 || variable2 < 5000 && 0.3 || variable2 < 10000 && 0.1 || 0;
    if (variable3.length == 0)
        return 0;
    let variable5 = 0;
    let variable6 = 0;
    for (let i = 0; i < variable3.length; i++) {
        const variable7 = variable3[i];
        if (variable7 && !isNaN(variable7)) {
            variable5 += 1;
            if (variable7 >= 500 && variable7 < 600) {
                variable6 += 1;
            }
        }
    }
    const func0 = 1 - variable4 * (variable6 / variable5);
    variable0.healthScore = func0;
    variable0.scoredRequestCount = variable0.requestCount;
    return func0;
}",compute a backend health score with time + status codes,Calculates the health score of a request .,Returns a function that calculates the health score .,1,Prediction1
"function configureExpress(config, done) {
  var portfinder = require('portfinder');

  tmp.dir(function(err, filepath){
    handles.filepath = filepath;

    portfinder.getPort(function (err, port) {
      if (err) throw(err);

      handles.port = port;

      fs.writeFileSync(path.join(handles.filepath, 'index.txt'), 'hello, world');

      app.use(proxy.initialize(config));
      app.use(express.static(handles.filepath));

      handles.server = require('http').createServer(app);
      handles.server.listen(handles.port, function() {
        done(null, handles.port);
      });
    });
  });
}","function func0(variable0, variable1) {
    var variable2 = require('portfinder');
    tmp.dir(function (err, filepath) {
        handles.filepath = filepath;
        variable2.getPort(function (err, port) {
            if (err)
                throw err;
            handles.port = port;
            fs.writeFileSync(path.join(handles.filepath, 'index.txt'), 'hello, world');
            app.use(proxy.initialize(variable0));
            app.use(express.static(handles.filepath));
            handles.server = require('http').createServer(app);
            handles.server.listen(handles.port, function () {
                variable1(null, handles.port);
            });
        });
    });
}",Configures an express instance on a dynamically assigned port for serving static files and proxying requests based on the config .,Start the server,This function is the main entry point of the function,1,Prediction1
"function initSocket() {
    tracker = new MessageTracker({
      id: self.url ? self.url.href : self.socketPath,
      parser: new Parser({log: log})
    });

    // This won't be set on TLS. So. Very. Annoying.
    if (typeof (socket.setKeepAlive) !== 'function') {
      socket.setKeepAlive = function setKeepAlive(enable, delay) {
        return socket.socket ?
          socket.socket.setKeepAlive(enable, delay) : false;
      };
    }

    socket.on('data', function onData(data) {
      if (log.trace())
        log.trace('data event: %s', util.inspect(data));

      tracker.parser.write(data);
    });

    // The ""router""
    tracker.parser.on('message', function onMessage(message) {
      message.connection = self._socket;
      var callback = tracker.fetch(message.messageID);

      if (!callback) {
        log.error({message: message.json}, 'unsolicited message');
        return false;
      }

      return callback(message);
    });

    tracker.parser.on('error', function onParseError(err) {
      self.emit('error', new VError(err, 'Parser error for %s',
            tracker.id));
      self.connected = false;
      socket.end();
    });
  }","function func0() {
    tracker = new MessageTracker({
        id: self.url ? self.url.href : self.socketPath,
        parser: new Parser({ log: log })
    });
    if (typeof socket.setKeepAlive !== 'function') {
        socket.setKeepAlive = function setKeepAlive(enable, delay) {
            return socket.socket ? socket.socket.setKeepAlive(enable, delay) : false;
        };
    }
    socket.on('data', function onData(data) {
        if (log.trace())
            log.trace('data event: %s', util.inspect(data));
        tracker.parser.write(data);
    });
    tracker.parser.on('message', function onMessage(message) {
        message.connection = self._socket;
        var callback = tracker.fetch(message.messageID);
        if (!callback) {
            log.error({ message: message.json }, 'unsolicited message');
            return false;
        }
        return callback(message);
    });
    tracker.parser.on('error', function onParseError(err) {
        self.emit('error', new VError(err, 'Parser error for %s', tracker.id));
        self.connected = false;
        socket.end();
    });
}",Initialize socket events and LDAP parser .,Initialize a new socket connection .,This function is called when the socket is connected,1,Prediction1
"function popupExecute(execute, url, name, options, callback) {
    var popupName = name || defaultPopupName();
    var popupOptions = optionsResolveCentered(assign({}, defaultOptions, options));
    var popupCallback = callback || function noop() {};
    var optionsString = optionsToString(popupOptions);
    var win = execute(url, popupName, optionsString);
    var isMessageSent = false;
    var interval;

    function popupCallbackOnce(err, data) {
        if (!isMessageSent) {
            isMessageSent = true;
            popupCallback(err, data);
        }
    }

    function onMessage(message) {
        var data = message ? message.data : undefined;

        if (data) {
            popupCallbackOnce(undefined, data);
            window.removeEventListener(""message"", onMessage);
        }
    }

    window.addEventListener(""message"", onMessage, false);

    if (win) {
        interval = setInterval(function closePopupCallback() {
            if (win == null || win.closed) {
                setTimeout(function delayWindowClosing() {
                    clearInterval(interval);
                    popupCallbackOnce(new Error(""Popup closed""));
                }, 500);
            }
        }, 100);
    } else {
        popupCallbackOnce(new Error(""Popup blocked""));
    }

    return win;
}","function func0(variable0, variable1, variable2, variable3, variable4) {
    var variable5 = variable2 || defaultPopupName();
    var variable6 = optionsResolveCentered(assign({}, defaultOptions, variable3));
    var variable7 = variable4 || function noop() {
    };
    var variable8 = optionsToString(variable6);
    var variable9 = variable0(variable1, variable5, variable8);
    var variable10 = false;
    var variable11;
    function func1(variable12, variable13) {
        if (!variable10) {
            variable10 = true;
            variable7(variable12, variable13);
        }
    }
    function func2(variable14) {
        var variable13 = variable14 ? variable14.variable13 : undefined;
        if (variable13) {
            func1(undefined, variable13);
            window.removeEventListener('message', func2);
        }
    }
    window.addEventListener('message', func2, false);
    if (variable9) {
        variable11 = setInterval(function closePopupCallback() {
            if (variable9 == null || variable9.closed) {
                setTimeout(function delayWindowClosing() {
                    clearInterval(variable11);
                    func1(new Error('Popup closed'));
                }, 500);
            }
        }, 100);
    } else {
        func1(new Error('Popup blocked'));
    }
    return variable9;
}",Open a popup using the first argument . Wait for it to close . Returns the window object,Creates a new popup .,Creates a new instance of a popup with the given parameters .,1,Tie
"function utf16EncodeAsString(codePoint) {
            ts.Debug.assert(0x0 <= codePoint && codePoint <= 0x10FFFF);
            if (codePoint <= 65535) {
                return String.fromCharCode(codePoint);
            }
            var codeUnit1 = Math.floor((codePoint - 65536) / 1024) + 0xD800;
            var codeUnit2 = ((codePoint - 65536) % 1024) + 0xDC00;
            return String.fromCharCode(codeUnit1, codeUnit2);
        }","function func0(variable0) {
    ts.Debug.assert(0 <= variable0 && variable0 <= 1114111);
    if (variable0 <= 65535) {
        return String.fromCharCode(variable0);
    }
    var variable1 = Math.floor((variable0 - 65536) / 1024) + 55296;
    var variable2 = (variable0 - 65536) % 1024 + 56320;
    return String.fromCharCode(variable1, variable2);
}",Derived from the 10 . 1 . 1 UTF16Encoding of the ES6 Spec .,Converts a number to a UTF - 16 string .,Returns a string representation of a variable 0 .,1,Prediction1
"function getKnexInstance(config, registry = _registry, logger = console) {
  validate.notNil(config, 'Config is null or undefined');
  validate.notNil(config.client, 'DB client is null or undefined');

  const { host, database, user } = config.connection;
  const connectionTimeout = config.acquireConnectionTimeout;

  logger.info(`Init db: ${user}/<Password omitted>@${host} db: ${database}`);
  logger.info(`Timeout: ${connectionTimeout}`);

  const knex = module.exports._initKnexInstance(config);
  module.exports.registerKnexInstance(knex, registry);
  // unfortunately, we can't check heartbeat here and fail-fast, as this initialization is synchronous
  return knex;
}","function func0(variable0, registry = _registry, logger = console) {
    validate.notNil(variable0, 'Config is null or undefined');
    validate.notNil(variable0.client, 'DB client is null or undefined');
    const {host, database, user} = variable0.connection;
    const variable1 = variable0.acquireConnectionTimeout;
    logger.info(`Init db: ${ user }/<Password omitted>@${ host } db: ${ database }`);
    logger.info(`Timeout: ${ variable1 }`);
    const variable2 = module.exports._initKnexInstance(variable0);
    module.exports.registerKnexInstance(variable2, registry);
    return variable2;
}",Get Knex instance without validating the connection,Creates a new knex instance .,Function to initialize a knex instance,1,Tie
"function getBaseConfig(isProd) {
  // get library details from JSON config
  const libraryEntryPoint = path.join('src', LIBRARY_DESC.entry);

  // generate webpack base config
  return {
    entry: [
      // ""babel-polyfill"",
      path.join(__dirname, libraryEntryPoint),
    ],
    output: {
      devtoolLineToLine: true,
      pathinfo: true,
    },
    module: {
      preLoaders: [
        {
          test: /\.js$/,
          exclude: /(node_modules|bower_components)/,
          loader: ""eslint-loader"",
        },
      ],
      loaders: [
        {
          exclude: /(node_modules|bower_components)/,
          loader: ""babel-loader"",
          plugins: [
            ""transform-runtime"",
          ],
          query: {
            presets: [
              ""es2015"",
              ""stage-0"",
              ""stage-1"",
              ""stage-2"",
            ],
            cacheDirectory: false,
          },
          test: /\.js$/,
        },
      ],
    },
    eslint: {
      configFile: './.eslintrc',
    },
    resolve: {
      root: path.resolve('./src'),
      extensions: ['', '.js'],
    },
    devtool: isProd ? ""source-map""/* null*/ : ""source-map""/* '#eval-source-map'*/,
    debug: !isProd,
    plugins: isProd ? [
      new webpack.DefinePlugin({ 'process.env': { NODE_ENV: '""production""' } }),
      new UglifyJsPlugin({
        compress: { warnings: true },
        minimize: true,
        sourceMap: true,
      }),
      // Prod plugins here
    ] : [
      new webpack.DefinePlugin({ 'process.env': { NODE_ENV: '""development""' } }),
      new UglifyJsPlugin({
        compress: { warnings: true },
        minimize: true,
        sourceMap: true,
      }),
      // Dev plugins here
    ],
  };
}","function func0(variable0) {
    const variable1 = path.join('src', LIBRARY_DESC.entry);
    return {
        entry: [path.join(__dirname, variable1)],
        output: {
            devtoolLineToLine: true,
            pathinfo: true
        },
        module: {
            preLoaders: [{
                    test: /\.js$/,
                    exclude: /(node_modules|bower_components)/,
                    loader: 'eslint-loader'
                }],
            loaders: [{
                    exclude: /(node_modules|bower_components)/,
                    loader: 'babel-loader',
                    plugins: ['transform-runtime'],
                    query: {
                        presets: [
                            'es2015',
                            'stage-0',
                            'stage-1',
                            'stage-2'
                        ],
                        cacheDirectory: false
                    },
                    test: /\.js$/
                }]
        },
        eslint: { configFile: './.eslintrc' },
        resolve: {
            root: path.resolve('./src'),
            extensions: [
                '',
                '.js'
            ]
        },
        devtool: variable0 ? 'source-map' : 'source-map',
        debug: !variable0,
        plugins: variable0 ? [
            new webpack.DefinePlugin({ 'process.env': { NODE_ENV: '""production""' } }),
            new UglifyJsPlugin({
                compress: { warnings: true },
                minimize: true,
                sourceMap: true
            })
        ] : [
            new webpack.DefinePlugin({ 'process.env': { NODE_ENV: '""development""' } }),
            new UglifyJsPlugin({
                compress: { warnings: true },
                minimize: true,
                sourceMap: true
            })
        ]
    };
}",Build base config,Creates a webpack config object .,Create a webpack config object .,1,Tie
"function updateTableUI()
   {
      var table = $('.control-table tbody');

      table.off('mouseenter', 'tr', onControlTableRowMouseOver);
      table.off('mouseleave', 'tr', onControlTableRowMouseOver);
      table.off('contextmenu', 'tr', onControlTableRowContextClick);

      table.empty();

      if (data)
      {
         data.nodes.forEach(function(node)
         {
            var nd = node.packageData;
            var name = appOptions.showFullNames ? nd.actualPackageName : nd.packageName;
            var isAliased = nd.isAlias ? ' isAliased' : '';

            var tr = $(
             '<tr>' +
                '<td class=""mdl-data-table__cell--non-numeric' + isAliased + '"">' + name + '</td>' +
                '<td class=""mdl-data-table__cell--non-numeric"">' + nd.jspmType + '</td>' +
                '<td class=""mdl-data-table__cell--non-numeric"">' + nd.version + '</td>' +
                '<td class=""mdl-data-table__cell--non-numeric"">' + node.minLevel + '</td>' +
             '</tr>');

            table.append(tr);

            tr.on('mouseenter', onControlTableRowMouseOver.bind(this, nodes, links, node, true));
            tr.on('mouseleave', onControlTableRowMouseOver.bind(this, nodes, links, node, false));
            tr.on('contextmenu', onControlTableRowContextClick.bind(this, node));
         });

         // Removes sort order for any header and signals update for new data
         $('#nodeTable th').removeClass('headerSortDown');
         $('#nodeTable th').removeClass('headerSortUp');
         $('#nodeTable').trigger('update');

         updateTableUIExtent();
      }
   }","function func0() {
    var variable0 = $('.control-table tbody');
    variable0.off('mouseenter', 'tr', onControlTableRowMouseOver);
    variable0.off('mouseleave', 'tr', onControlTableRowMouseOver);
    variable0.off('contextmenu', 'tr', onControlTableRowContextClick);
    variable0.empty();
    if (data) {
        data.nodes.forEach(function (node) {
            var nd = node.packageData;
            var name = appOptions.showFullNames ? nd.actualPackageName : nd.packageName;
            var isAliased = nd.isAlias ? ' isAliased' : '';
            var tr = $('<tr>' + '<td class=""mdl-data-table__cell--non-numeric' + isAliased + '"">' + name + '</td>' + '<td class=""mdl-data-table__cell--non-numeric"">' + nd.jspmType + '</td>' + '<td class=""mdl-data-table__cell--non-numeric"">' + nd.version + '</td>' + '<td class=""mdl-data-table__cell--non-numeric"">' + node.minLevel + '</td>' + '</tr>');
            variable0.append(tr);
            tr.on('mouseenter', onControlTableRowMouseOver.bind(this, nodes, links, node, true));
            tr.on('mouseleave', onControlTableRowMouseOver.bind(this, nodes, links, node, false));
            tr.on('contextmenu', onControlTableRowContextClick.bind(this, node));
        });
        $('#nodeTable th').removeClass('headerSortDown');
        $('#nodeTable th').removeClass('headerSortUp');
        $('#nodeTable').trigger('update');
        updateTableUIExtent();
    }
}",Builds the table UI with all current node data and associates the active events on each row .,Removes all control - table elements .,This function is called when the control table is empty .,1,Prediction1
"function errorHandler (app, err) {
  delete app.connection
  // log and adjust err message
  const msg = `""app.connection"" unexpectedly errored: ${err.message}`
  debug(msg, err)
  err.message = msg
  // throw the error
  throw err
}","function func0(variable0, variable1) {
    delete variable0.connection;
    const variable2 = `""app.connection"" unexpectedly errored: ${ variable1.message }`;
    debug(variable2, variable1);
    variable1.message = variable2;
    throw variable1;
}",connection error handler,Handle an unexpected connection error .,This function is used to throw a connection error .,1,Tie
"function random(number = 1) {
  if (1 > number) {
    throw Error(`Can't use numbers bellow 1, ${number} passed`);
  }

  if (number === 1) {
    return getRandomArrValue(dinosaurs);
  } else {
    const l = dinosaurs.length - 1;
    return new Array(number).fill().map(() => getRandomArrValue(dinosaurs, 0, l));
  }
}","function func0(number = 1) {
    if (1 > number) {
        throw Error(`Can't use numbers bellow 1, ${ number } passed`);
    }
    if (number === 1) {
        return getRandomArrValue(dinosaurs);
    } else {
        const l = dinosaurs.length - 1;
        return new Array(number).fill().map(() => getRandomArrValue(dinosaurs, 0, l));
    }
}",Returns a random dinosaur or more random dinosaurs if number is set,Creates a random array of numbers .,Returns a random array of numbers,1,Tie
"function loadTheme(props) {
	var relPath = '/' + props.join('/') + '.yml',
		defaultsPath = path.resolve(base + '/scss/themes/default' + relPath),
		customPath = (custom) ? custom + relPath : null,
		defaultVars = {},
		customVars = null,
		result = {};

	// Try loading a custom theme file
	customVars = loadYamlFile(customPath);

	// If merge mode is set to ""replace"", don't even load the defaults
	if (customVars && customVars['merge-mode'] === 'replace') {
		result = _.omit(customVars, 'merge-mode');
	} else {
		defaultVars = loadYamlFile(defaultsPath);
		result = _.merge(defaultVars, customVars);
	}

	// Store variables in cached theme var
	_.set(theme, props.join('.'), result);

	return result;
}","function func0(variable0) {
    var variable1 = '/' + variable0.join('/') + '.yml', variable2 = path.resolve(base + '/scss/themes/default' + variable1), variable3 = custom ? custom + variable1 : null, variable4 = {}, variable5 = null, variable6 = {};
    variable5 = loadYamlFile(variable3);
    if (variable5 && variable5['merge-mode'] === 'replace') {
        variable6 = _.omit(variable5, 'merge-mode');
    } else {
        variable4 = loadYamlFile(variable2);
        variable6 = _.merge(variable4, variable5);
    }
    _.set(theme, variable0.join('.'), variable6);
    return variable6;
}",Load theme variables from a YAML file .,Load a theme . yaml file .,Function that takes an array of theme names and returns an object with theme name as key and value as value,1,Prediction1
"function Context (hook, opts) {
    this.hook = hook;

    // create new object, to avoid affecting input opts in other places
    // For example context.opts.plugin = Object is done, then it affects by reference
    this.opts = Object.assign({}, opts);
    this.cmdLine = process.argv.join(' ');

    // Lazy-load cordova to avoid cyclical dependency
    Object.defineProperty(this, 'cordova', {
        get () { return this.requireCordovaModule('cordova-lib').cordova; }
    });
}","function func0(variable0, variable1) {
    this.variable0 = variable0;
    this.variable1 = Object.assign({}, variable1);
    this.cmdLine = process.argv.join(' ');
    Object.defineProperty(this, 'cordova', {
        get() {
            return this.requireCordovaModule('cordova-lib').cordova;
        }
    });
}",Creates hook script context,Creates a new Cordova instance .,Creates a new func0 instance,1,Prediction1
"function classifyTokenType(tokenKind, token) {
                if (ts.isKeyword(tokenKind)) {
                    return 3 /* keyword */;
                }
                // Special case < and >  If they appear in a generic context they are punctuation,
                // not operators.
                if (tokenKind === 25 /* LessThanToken */ || tokenKind === 27 /* GreaterThanToken */) {
                    // If the node owning the token has a type argument list or type parameter list, then
                    // we can effectively assume that a '<' and '>' belong to those lists.
                    if (token && ts.getTypeArgumentOrTypeParameterList(token.parent)) {
                        return 10 /* punctuation */;
                    }
                }
                if (ts.isPunctuation(tokenKind)) {
                    if (token) {
                        if (tokenKind === 56 /* EqualsToken */) {
                            // the '=' in a variable declaration is special cased here.
                            if (token.parent.kind === 211 /* VariableDeclaration */ ||
                                token.parent.kind === 141 /* PropertyDeclaration */ ||
                                token.parent.kind === 138 /* Parameter */) {
                                return 5 /* operator */;
                            }
                        }
                        if (token.parent.kind === 181 /* BinaryExpression */ ||
                            token.parent.kind === 179 /* PrefixUnaryExpression */ ||
                            token.parent.kind === 180 /* PostfixUnaryExpression */ ||
                            token.parent.kind === 182 /* ConditionalExpression */) {
                            return 5 /* operator */;
                        }
                    }
                    return 10 /* punctuation */;
                }
                else if (tokenKind === 8 /* NumericLiteral */) {
                    return 4 /* numericLiteral */;
                }
                else if (tokenKind === 9 /* StringLiteral */) {
                    return 6 /* stringLiteral */;
                }
                else if (tokenKind === 10 /* RegularExpressionLiteral */) {
                    // TODO: we should get another classification type for these literals.
                    return 6 /* stringLiteral */;
                }
                else if (ts.isTemplateLiteralKind(tokenKind)) {
                    // TODO (drosen): we should *also* get another classification type for these literals.
                    return 6 /* stringLiteral */;
                }
                else if (tokenKind === 69 /* Identifier */) {
                    if (token) {
                        switch (token.parent.kind) {
                            case 214 /* ClassDeclaration */:
                                if (token.parent.name === token) {
                                    return 11 /* className */;
                                }
                                return;
                            case 137 /* TypeParameter */:
                                if (token.parent.name === token) {
                                    return 15 /* typeParameterName */;
                                }
                                return;
                            case 215 /* InterfaceDeclaration */:
                                if (token.parent.name === token) {
                                    return 13 /* interfaceName */;
                                }
                                return;
                            case 217 /* EnumDeclaration */:
                                if (token.parent.name === token) {
                                    return 12 /* enumName */;
                                }
                                return;
                            case 218 /* ModuleDeclaration */:
                                if (token.parent.name === token) {
                                    return 14 /* moduleName */;
                                }
                                return;
                            case 138 /* Parameter */:
                                if (token.parent.name === token) {
                                    return 17 /* parameterName */;
                                }
                                return;
                        }
                    }
                    return 2 /* identifier */;
                }
            }","function func0(variable0, variable1) {
    if (ts.isKeyword(variable0)) {
        return 3;
    }
    if (variable0 === 25 || variable0 === 27) {
        if (variable1 && ts.getTypeArgumentOrTypeParameterList(variable1.parent)) {
            return 10;
        }
    }
    if (ts.isPunctuation(variable0)) {
        if (variable1) {
            if (variable0 === 56) {
                if (variable1.parent.kind === 211 || variable1.parent.kind === 141 || variable1.parent.kind === 138) {
                    return 5;
                }
            }
            if (variable1.parent.kind === 181 || variable1.parent.kind === 179 || variable1.parent.kind === 180 || variable1.parent.kind === 182) {
                return 5;
            }
        }
        return 10;
    } else if (variable0 === 8) {
        return 4;
    } else if (variable0 === 9) {
        return 6;
    } else if (variable0 === 10) {
        return 6;
    } else if (ts.isTemplateLiteralKind(variable0)) {
        return 6;
    } else if (variable0 === 69) {
        if (variable1) {
            switch (variable1.parent.kind) {
            case 214:
                if (variable1.parent.name === variable1) {
                    return 11;
                }
                return;
            case 137:
                if (variable1.parent.name === variable1) {
                    return 15;
                }
                return;
            case 215:
                if (variable1.parent.name === variable1) {
                    return 13;
                }
                return;
            case 217:
                if (variable1.parent.name === variable1) {
                    return 12;
                }
                return;
            case 218:
                if (variable1.parent.name === variable1) {
                    return 14;
                }
                return;
            case 138:
                if (variable1.parent.name === variable1) {
                    return 17;
                }
                return;
            }
        }
        return 2;
    }
}",for accurate classification the actual token should be passed in . however for cases like disabled merge code classification we just get the token kind and classify based on that instead .,Returns the number of tokens for a given token .,Returns the number of occurrences of variable0 and variable1 .,1,Prediction1
"function createProgramArgsUpdaterFunc(programArgs) {
  return (program) => {
    let programArgsFact = buildProgramArgsPredicate(programArgs);
    program.getFacts().add(programArgsFact);
    return Promise.resolve(program);
  };
}","function func0(variable0) {
    return program => {
        let programArgsFact = buildProgramArgsPredicate(variable0);
        program.getFacts().add(programArgsFact);
        return Promise.resolve(program);
    };
}",Create a function to update a given program with the given program arguments,Creates a function that will return a promise that resolves to a program .,Creates a function that will add a variable0 to the program .,1,Prediction1
"function showNumber(addr, num, decimalplaces, mindigits, leftjustified, pos, dontclear) { 

	    if(addr<0 || addr>=maxDevices)
			throw 'address out of range';
		
		num = formatNumber(num, decimalplaces, mindigits); 
	
		// internally, pos is 0 on the right, so we set defaults, and convert
		if(typeof pos === 'undefined') { 
			if(leftjustified) { 
				pos = 7; 
			} else { 
				pos = 0; 
			}
		} else pos = 7-pos; 
		
		// get rid of the decimal place but remember where it was
		var decimalplace; 
		if(num.indexOf('.')<0) decimalplace = -1; 
		else {
			decimalplace = num.length - num.indexOf('.') -1; 
			num = num.split('.').join('');
		}
		if(leftjustified) { 
			pos-=(num.length-1); 
		}
	
		for(var i = 0; i<8; i++) { 
			var offset = i+pos; 
			var char = num.charAt(num.length-1-i); 
			
			if((offset<8 && offset>=0) && (!dontclear || char!='')) 
			{
				if(char=='-') setChar(addr, offset, char, i>0 && i==decimalplace); 
				else setDigit(addr, offset, parseInt(char), i>0 && i==decimalplace); 
			}
		}
	
	}","function func0(variable0, variable1, variable2, variable3, variable4, variable5, variable6) {
    if (variable0 < 0 || variable0 >= maxDevices)
        throw 'address out of range';
    variable1 = formatNumber(variable1, variable2, variable3);
    if (typeof variable5 === 'undefined') {
        if (variable4) {
            variable5 = 7;
        } else {
            variable5 = 0;
        }
    } else
        variable5 = 7 - variable5;
    var variable7;
    if (variable1.indexOf('.') < 0)
        variable7 = -1;
    else {
        variable7 = variable1.length - variable1.indexOf('.') - 1;
        variable1 = variable1.split('.').join('');
    }
    if (variable4) {
        variable5 -= variable1.length - 1;
    }
    for (var i = 0; i < 8; i++) {
        var variable8 = i + variable5;
        var variable9 = variable1.charAt(variable1.length - 1 - i);
        if (variable8 < 8 && variable8 >= 0 && (!variable6 || variable9 != '')) {
            if (variable9 == '-')
                setChar(variable0, variable8, variable9, i > 0 && i == variable7);
            else
                setDigit(variable0, variable8, parseInt(variable9), i > 0 && i == variable7);
        }
    }
}",pos is passed in as 0 to 7 0 on the left 7 on the right,Set a device address .,Function to set a device address,1,Tie
"function parse(messageType, args) {
        const options = getOptions(messageType);
        /** Interpreter */
        if (typeof options.interpreter === ""function"") {
            for (const index in args) {
                /** Let string be without additional ' ' */
                if (typeof args[index] === ""string"") {
                    continue;
                }
                args[index] = options.interpreter(args[index]);
            }
        }
        /** Label */
        if (options.labels) {
            args.unshift(`[${messageType.toUpperCase()}]`);
        }
        /** Timestamp */
        if (options.timestamp) {
            switch (typeof options.timestamp) {
                case ""boolean"":
                    args.unshift(`[${new Date().toLocaleString()}]`);
                    break;
                case ""string"":
                    args.unshift(`[${moment().format(options.timestamp)}]`);
                    break;
                default:
                    throw new Error(`Invalid timestamp type (${typeof options.timestamp}). Should be (boolean | string)`);
            }
        }
        return args.join("" "");
    }","function func0(variable0, variable1) {
    const variable2 = getOptions(variable0);
    if (typeof variable2.interpreter === 'function') {
        for (const index in variable1) {
            if (typeof variable1[index] === 'string') {
                continue;
            }
            variable1[index] = variable2.interpreter(variable1[index]);
        }
    }
    if (variable2.labels) {
        variable1.unshift(`[${ variable0.toUpperCase() }]`);
    }
    if (variable2.timestamp) {
        switch (typeof variable2.timestamp) {
        case 'boolean':
            variable1.unshift(`[${ new Date().function toLocaleString() { [native code] }() }]`);
            break;
        case 'string':
            variable1.unshift(`[${ moment().format(variable2.timestamp) }]`);
            break;
        default:
            throw new Error(`Invalid timestamp type (${ typeof variable2.timestamp }). Should be (boolean | string)`);
        }
    }
    return variable1.join(' ');
}",Prepare message and return as string,function 0 - > string,Creates a string from the given options .,0,Prediction2
"function makeAsyncNonIterator(bodyFunc, config, semaphore) {
    // Return a function that executes fn in a fiber and returns a promise of fn's result.
    return function nonIterable() {
        // Get all the arguments passed in, as an array.
        var argsAsArray = new Array(arguments.length);
        for (var i = 0; i < argsAsArray.length; ++i)
            argsAsArray[i] = arguments[i];
        // Remove concurrency restrictions for nested calls, to avoid race conditions.
        if (FiberMgr.isExecutingInFiber())
            this._semaphore = Semaphore.unlimited;
        // Configure the run context.
        var runContext = new RunContext(bodyFunc, this, argsAsArray, function () { return semaphore.leave(); });
        if (config.returnValue !== Config.NONE) {
            var resolver = defer();
            runContext.resolver = resolver;
        }
        if (config.acceptsCallback && argsAsArray.length && _.isFunction(argsAsArray[argsAsArray.length - 1])) {
            var callback = argsAsArray.pop();
            runContext.callback = callback;
        }
        // Execute bodyFunc to completion in a coroutine. For thunks, this is a lazy operation.
        if (config.returnValue === Config.THUNK) {
            var thunk = function (done) {
                if (done)
                    resolver.promise.then(function (val) { return done(null, val); }, function (err) { return done(err); });
                semaphore.enter(function () { return FiberMgr.create().run(runContext); });
            };
        }
        else {
            semaphore.enter(function () { return FiberMgr.create().run(runContext); });
        }
        // Return the appropriate value.
        switch (config.returnValue) {
            case Config.PROMISE: return resolver.promise;
            case Config.THUNK: return thunk;
            case Config.RESULT: return await(resolver.promise);
            case Config.NONE: return;
        }
    };
}","function func0(variable0, variable1, variable2) {
    return function nonIterable() {
        var argsAsArray = new Array(arguments.length);
        for (var i = 0; i < argsAsArray.length; ++i)
            argsAsArray[i] = arguments[i];
        if (FiberMgr.isExecutingInFiber())
            this._semaphore = Semaphore.unlimited;
        var runContext = new RunContext(variable0, this, argsAsArray, function () {
            return variable2.leave();
        });
        if (variable1.returnValue !== Config.NONE) {
            var resolver = defer();
            runContext.resolver = resolver;
        }
        if (variable1.acceptsCallback && argsAsArray.length && _.isFunction(argsAsArray[argsAsArray.length - 1])) {
            var callback = argsAsArray.pop();
            runContext.callback = callback;
        }
        if (variable1.returnValue === Config.THUNK) {
            var thunk = function (done) {
                if (done)
                    resolver.promise.then(function (val) {
                        return done(null, val);
                    }, function (err) {
                        return done(err);
                    });
                variable2.enter(function () {
                    return FiberMgr.create().run(runContext);
                });
            };
        } else {
            variable2.enter(function () {
                return FiberMgr.create().run(runContext);
            });
        }
        switch (variable1.returnValue) {
        case Config.PROMISE:
            return resolver.promise;
        case Config.THUNK:
            return thunk;
        case Config.RESULT:
            return await(resolver.promise);
        case Config.NONE:
            return;
        }
    };
}",Function for creating non - iterable suspendable functions .,Creates a function that runs a function on a non iterable Fiber .,Creates a function that returns a function that returns an iterable of values .,1,Prediction1
"function Random(seed) {
    this.multiplier = 16807;
    this.modulus = 0x7fffffff;
    this.seed = seed;
    this.mq = Math.floor(this.modulus / this.multiplier);
    this.mr = this.modulus % this.multiplier;
}","function func0(variable0) {
    this.multiplier = 16807;
    this.modulus = 2147483647;
    this.variable0 = variable0;
    this.mq = Math.floor(this.modulus / this.multiplier);
    this.mr = this.modulus % this.multiplier;
}",Lehmer random module used by the app to generate request ids,Creates a new func0 object .,Creates a new instance of this class .,0,Prediction2
"function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          )

        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}","function func0(variable0, variable1, variable2, variable3, variable4) {
    if (true) {
        for (var typeSpecName in variable0) {
            if (variable0.function hasOwnProperty() { [native code] }(typeSpecName)) {
                var error;
                try {
                    if (typeof variable0[typeSpecName] !== 'function') {
                        var err = Error((variable3 || 'React class') + ': ' + variable2 + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof variable0[typeSpecName] + '`.');
                        err.name = 'Invariant Violation';
                        throw err;
                    }
                    error = variable0[typeSpecName](variable1, typeSpecName, variable3, variable2, null, ReactPropTypesSecret);
                } catch (ex) {
                    error = ex;
                }
                if (error && !(error instanceof Error)) {
                    printWarning((variable3 || 'React class') + ': type specification of ' + variable2 + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + typeof error + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');
                }
                if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                    loggedTypeFailures[error.message] = true;
                    var stack = variable4 ? variable4() : '';
                    printWarning('Failed ' + variable2 + ' type: ' + error.message + (stack != null ? stack : ''));
                }
            }
        }
    }
}",Assert that the values match with the type specs . Error messages are memorized and will only be shown once .,Check if a type specification is valid .,Checks that the type specification of variable0 is valid .,1,Prediction1
"function inspectFD(emitted) {
            const { node } = emitted,
                visibilityModifiers = [""public"", ""external"", ""internal"", ""private""];
            const modifiers = (node.modifiers || []),
                firstVisibilityModifierIndex = modifiers.findIndex(m => visibilityModifiers.includes(m.name));

            // If no visibility modifiers exist in function declaration, exit now
            if (emitted.exit || firstVisibilityModifierIndex === -1) {
                return;
            }

            const firstNonVisModifBeforeFirstVisModif = modifiers.slice(0, firstVisibilityModifierIndex).find(m => !visibilityModifiers.includes(m.name));

            // TODO: Add fix() for this rule
            if (firstNonVisModifBeforeFirstVisModif) {
                const issue = {
                    node: modifiers[firstVisibilityModifierIndex],
                    message: `Visibility modifier ""${modifiers[firstVisibilityModifierIndex].name}"" should come before other modifiers.`
                };
                context.report(issue);
            }
        }","function func0(variable0) {
    const {node} = variable0, variable1 = [
            'public',
            'external',
            'internal',
            'private'
        ];
    const variable2 = node.variable2 || [], variable3 = variable2.findIndex(m => variable1.includes(m.name));
    if (variable0.exit || variable3 === -1) {
        return;
    }
    const variable4 = variable2.slice(0, variable3).find(m => !variable1.includes(m.name));
    if (variable4) {
        const issue = {
            node: variable2[variable3],
            message: `Visibility modifier ""${ variable2[variable3].name }"" should come before other modifiers.`
        };
        context.report(issue);
    }
}",Find index of the first visibility modifier in declaration . Find the first non - VM before this first VM found above . If non - VM found report the VM .,Check if variable0 has visibility modifier,Check if a node has a visibility modifier .,0,Prediction2
"function build() {
  log.info(`Creating an optimized production build...`)
  const compiler = createWebpackCompiler(
    () => {
      log.ok(`The ${chalk.cyan(relativeAppBuildPath)} folder is ready to be deployed.`)
    },
    () => {
      log.err(`Aborting`)
      process.exit(2)
    }
  )

  return new Promise((resolve, reject) => {
    compiler.run((err, stats) => {
      if (err) {
        return reject(err)
      }

      return resolve(stats)
    })
  })
}","function func0() {
    log.info(`Creating an optimized production build...`);
    const variable0 = createWebpackCompiler(() => {
        log.ok(`The ${ chalk.cyan(relativeAppBuildPath) } folder is ready to be deployed.`);
    }, () => {
        log.err(`Aborting`);
        process.exit(2);
    });
    return new Promise((resolve, reject) => {
        variable0.run((err, stats) => {
            if (err) {
                return reject(err);
            }
            return resolve(stats);
        });
    });
}",Create the production build and print the deployment instructions .,Creates an optimized production build .,Create an optimized production build,1,Tie
"function findOptionInChoice(choice, optionId, dataElementSpecs) {
  // First look for a direct match
  for (const option of choice.aggregateOptions) {
    if (optionId.equals(option.identifier)) {
      return option;
    }
  }
  // Then look for a match on one of the selected options's base types
  // E.g., if choice has Quantity but selected option is IntegerQuantity
  for (const option of choice.aggregateOptions) {
    if (checkHasBaseType(optionId, option.identifier, dataElementSpecs)) {
      return option;
    }
  }
  return null;
}","function func0(variable0, variable1, variable2) {
    for (const option of variable0.aggregateOptions) {
        if (variable1.equals(option.identifier)) {
            return option;
        }
    }
    for (const option of variable0.aggregateOptions) {
        if (checkHasBaseType(variable1, option.identifier, variable2)) {
            return option;
        }
    }
    return null;
}",Searches the aggregate options of a choice for the specified option .,Find an aggregate option by its identifier .,Returns the first aggregate option that matches variable1 and variable2,1,Prediction1
"function getClockId(clockId) {
  let buffer = clockId;
  if (typeof clockId === 'string') {
    buffer = utils.allocBufferFromString(clockId, 'ascii');
  }
  if (!(buffer instanceof Buffer)) {
    //Generate
    buffer = getRandomBytes(2);
  }
  else if (buffer.length !== 2) {
    throw new Error('Clock identifier must have 2 bytes');
  }
  return buffer;
}","function func0(variable0) {
    let variable1 = variable0;
    if (typeof variable0 === 'string') {
        variable1 = utils.allocBufferFromString(variable0, 'ascii');
    }
    if (!(variable1 instanceof Buffer)) {
        variable1 = getRandomBytes(2);
    } else if (variable1.length !== 2) {
        throw new Error('Clock identifier must have 2 bytes');
    }
    return variable1;
}",Returns a buffer of length 2 representing the clock identifier,Creates a new clock identifier .,Function to generate a clock identifier,1,Tie
"function empty(value) {
  if (!value) return true;
  switch (is(value)) {
    case ""object"": return !Object.keys(value).length;
    case ""array"": return !value.length;
    default: return !value;
  }
}","function func0(variable0) {
    if (!variable0)
        return true;
    switch (is(variable0)) {
    case 'object':
        return !Object.keys(variable0).length;
    case 'array':
        return !variable0.length;
    default:
        return !variable0;
    }
}",Simple check to see if the provided stack is empty or falsy .,Checks if a value is empty .,Returns true if variable0 is empty,1,Prediction1
"function getMediaTypePriority(type, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(type, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}","function func0(variable0, variable1, variable2) {
    var variable3 = {
        o: -1,
        q: 0,
        s: 0
    };
    for (var i = 0; i < variable1.length; i++) {
        var variable4 = specify(variable0, variable1[i], variable2);
        if (variable4 && (variable3.s - variable4.s || variable3.q - variable4.q || variable3.o - variable4.o) < 0) {
            variable3 = variable4;
        }
    }
    return variable3;
}",Get the priority of a media type .,Given an array of objects returns the first object that matches the specified criteria .,function 0 - > variable1 - > variable2,1,Prediction1
"function clearError() {
    if (error) {
        infoDisplay.load.box.style.display = 'none';
        infoDisplay.errorMsg.style.display = 'none';
        error = false;
        fireEvent('errorcleared');
    }
}","function func0() {
    if (error) {
        infoDisplay.load.box.style.display = 'none';
        infoDisplay.errorMsg.style.display = 'none';
        error = false;
        fireEvent('errorcleared');
    }
}",Hides error message display .,This function is called at the beginning of the function,Clear the error display .,0,Prediction2
"function remove(scope, type) {
  if (scope === undefined) scope = ""general"";
  if (type === undefined) {
    delete _combines[scope];
    delete _reducers[scope];
  } else {
    delete _reducers[scope][type];
  }
}","function func0(variable0, variable1) {
    if (variable0 === undefined)
        variable0 = 'general';
    if (variable1 === undefined) {
        delete _combines[variable0];
        delete _reducers[variable0];
    } else {
        delete _reducers[variable0][variable1];
    }
}",remove - remove reducers by scope & type,Remove a reducers or combines .,Remove a function from the _combines map .,1,Prediction1
"function memoize(type, pattern, options, fn) {
  var key = utils.createKey(type + ':' + pattern, options);
  var disabled = options && options.cache === false;
  if (disabled) {
    braces.clearCache();
    return fn(pattern, options);
  }

  if (cache.hasOwnProperty(key)) {
    return cache[key];
  }

  var res = fn(pattern, options);
  cache[key] = res;
  return res;
}","function func0(variable0, variable1, variable2, variable3) {
    var variable4 = utils.createKey(variable0 + ':' + variable1, variable2);
    var variable5 = variable2 && variable2.cache === false;
    if (variable5) {
        braces.clearCache();
        return variable3(variable1, variable2);
    }
    if (cache.function hasOwnProperty() { [native code] }(variable4)) {
        return cache[variable4];
    }
    var variable6 = variable3(variable1, variable2);
    cache[variable4] = variable6;
    return variable6;
}",Memoize a generated regex or function . A unique key is generated from the method name pattern and user - defined options . Set options . memoize to false to disable .,function 0 - > variable1 - > variable2 - > variable3,Get a value from the cache .,0,Prediction2
"function compareHigher(a, b) {
  var numA = parseFloat(/[\d\.]+$/.exec(a)[0]);
  var numB = parseFloat(/[\d\.]+$/.exec(b)[0]);
  if (isNaN(numA) || (numB > numA)) {
    return +1;
  } else if (isNaN(numB) || (numA > numB)) {
    return -1;
  } else {
    return 0;
  }
}","function func0(variable0, variable1) {
    var variable2 = parseFloat(/[\d\.]+$/.exec(variable0)[0]);
    var variable3 = parseFloat(/[\d\.]+$/.exec(variable1)[0]);
    if (isNaN(variable2) || variable3 > variable2) {
        return +1;
    } else if (isNaN(variable3) || variable2 > variable3) {
        return -1;
    } else {
        return 0;
    }
}",Rank a vs b based on any numeric component in their string .,returns 1 if variable0 > variable1,Compare two numbers .,0,Prediction2
"function matchArray(m,a) {
    var from = 0, rest = false, restBindingResult, index, matcher, item,
    matchResult, restOfArray = [], i, result = {
      result: false,
      param: a
    };

    // If this isn't an array then it can't match
    if (!is(a, '[object Array]')) {
      return result;
    }

    // If there are more matchers than array elements it also can't match unless the
    // last matcher is a rest matcher
    if (m.length > a.length && !m[m.length - 1].name) {
      return result;
    }

    /**
     * If there are no predicates at all, this matches because it is 
     * already ensured that argument a is an array.
     */
    if(m.length === 0) {
      result.result = true;
      return result;
    }

    for(index=0;index<a.length;index++) {
      matcher = m[index];
      item = a[index];

      if(!matcher) {
        return result;
      }

      matchResult = matcher(item);
      if(!matchResult.result) {
        return result;
      }

      /**
       * If the rest of an array is matched, the predicate will
       * return an object that has a'rest' parameter. We can't
       * recognize the rest predicate by it's function name, because
       * it might be hidden behind a 'bind' call.
       */
      if(matchResult.rest) {
        restBindingResult = matchResult;
        from = index;
        rest = true;
        break;
      }
    }

    if(rest && restBindingResult.this_binding) {
      for(i = from; i < a.length; i++) {
        restOfArray[restOfArray.length] = a[i];
      }
      bindingContext[restBindingResult.this_binding] = restOfArray;
    }
    
    result.result = true;
    return result;
  }","function func0(variable0, variable1) {
    var variable2 = 0, variable3 = false, variable4, variable5, variable6, variable7, variable8, variable9 = [], variable10, variable11 = {
            variable11: false,
            param: variable1
        };
    if (!is(variable1, '[object Array]')) {
        return variable11;
    }
    if (variable0.length > variable1.length && !variable0[variable0.length - 1].name) {
        return variable11;
    }
    if (variable0.length === 0) {
        variable11.variable11 = true;
        return variable11;
    }
    for (variable5 = 0; variable5 < variable1.length; variable5++) {
        variable6 = variable0[variable5];
        variable7 = variable1[variable5];
        if (!variable6) {
            return variable11;
        }
        variable8 = variable6(variable7);
        if (!variable8.variable11) {
            return variable11;
        }
        if (variable8.variable3) {
            variable4 = variable8;
            variable2 = variable5;
            variable3 = true;
            break;
        }
    }
    if (variable3 && variable4.this_binding) {
        for (variable10 = variable2; variable10 < variable1.length; variable10++) {
            variable9[variable9.length] = variable1[variable10];
        }
        bindingContext[variable4.this_binding] = variable9;
    }
    variable11.variable11 = true;
    return variable11;
}",m is an array of predicates a is the array to match,Given a list of parameters and a list of parameters return a new parameter object .,Function that takes an array of variables and returns a variable11 object .,1,Prediction1
"function TorAgent(opts) {
  if (!(this instanceof TorAgent)) {
    return new TorAgent();
  }

  http.Agent.call(this, opts);

  this.socksHost   = opts.socksHost || 'localhost';
  this.socksPort   = opts.socksPort || 9050;
  this.defaultPort = 80;

  // Used when invoking TorAgent.create
  this.tor = opts.tor;

  // Prevent protocol check, wrap destroy
  this.protocol = null;
  this.defaultDestroy = this.destroy;
  this.destroy = this.destroyWrapper;
}","function func0(variable0) {
    if (!(this instanceof func0)) {
        return new func0();
    }
    http.Agent.call(this, variable0);
    this.socksHost = variable0.socksHost || 'localhost';
    this.socksPort = variable0.socksPort || 9050;
    this.defaultPort = 80;
    this.tor = variable0.tor;
    this.protocol = null;
    this.defaultDestroy = this.destroy;
    this.destroy = this.destroyWrapper;
}",An HTTP Agent for proxying requests through Tor using SOCKS5 .,Creates a new agent .,Creates an instance of func0 .,1,Prediction1
"function reset() {
	this._struct = [];
	this._structPointer = 0;

	var reAttachContext = (this._options.context == this._context); // Reattach the context pointer after reset?
	this._context = {
		_struct: this._struct,
		_structPointer: this._structPointer,
		_options: this._options,
		_deferredRunning: this._deferredRunning,
		hook: this.hook.bind(this),
		fire: this.fire.bind(this),
	};

	if (reAttachContext) this._options.context = this._context;
}","function func0() {
    this._struct = [];
    this._structPointer = 0;
    var variable0 = this._options.context == this._context;
    this._context = {
        _struct: this._struct,
        _structPointer: this._structPointer,
        _options: this._options,
        _deferredRunning: this._deferredRunning,
        hook: this.hook.bind(this),
        fire: this.fire.bind(this)
    };
    if (variable0)
        this._options.context = this._context;
}",}}} Reset all state variables and return the object into a pristine condition,This is the function that will be called when the function is called .,Creates a new instance of the class .,0,Prediction2
"function parseFile(filepath, config) {
  var contents;

  filepath = filepath || path.join(process.cwd(), '/json-proxy.json');

  // if we were passed a config file, read and parse it
  if (fs.existsSync(filepath)) {
    try {
      var data = fs.readFileSync(filepath);
      contents = JSON.parse(data.toString());
      config = parseConfig(contents, config);

      // replace the token $config_dir in the webroot arg
      if (config.server.webroot && config.server.webroot.length > 0) {
        config.server.webroot = config.server.webroot.replace(""$config_dir"", path.dirname(filepath));
      }
    } catch (ex) {
      throw new Error('Cannot parse the config file ""' + filepath + '"": ' + ex);
    }

  }

  return config;
}","function func0(variable0, variable1) {
    var variable2;
    variable0 = variable0 || path.join(process.cwd(), '/json-proxy.json');
    if (fs.existsSync(variable0)) {
        try {
            var data = fs.readFileSync(variable0);
            variable2 = JSON.parse(data.function toString() { [native code] }());
            variable1 = parseConfig(variable2, variable1);
            if (variable1.server.webroot && variable1.server.webroot.length > 0) {
                variable1.server.webroot = variable1.server.webroot.replace('$config_dir', path.dirname(variable0));
            }
        } catch (ex) {
            throw new Error('Cannot parse the config file ""' + variable0 + '"": ' + ex);
        }
    }
    return variable1;
}",reads a config file from either the config file specified on the command line or fallback to a file name json - proxy . config in the working directory return true if the file can be read otherwise return false,Parse the json - proxy . json file,Parses the json - proxy . json file .,0,Tie
"function resetProviders(names) {
        var tempProviders = this.originalProviders;
        var shouldFilter = Array.isArray(names);
    
        Object.keys(this.originalProviders).forEach(function resetProvider(originalProviderName) {
            if (shouldFilter && names.indexOf(originalProviderName) === -1) {
                return;
            }
            var parts = originalProviderName.split(DELIMITER);
            if (parts.length > 1) {
                parts.forEach(removeProviderMap, getNestedBottle.call(this, parts[0]));
            }
            removeProviderMap.call(this, originalProviderName);
            this.provider(originalProviderName, tempProviders[originalProviderName]);
        }, this);
    }","function func0(variable0) {
    var variable1 = this.originalProviders;
    var variable2 = Array.isArray(variable0);
    Object.keys(this.originalProviders).forEach(function resetProvider(originalProviderName) {
        if (variable2 && variable0.indexOf(originalProviderName) === -1) {
            return;
        }
        var parts = originalProviderName.split(DELIMITER);
        if (parts.length > 1) {
            parts.forEach(removeProviderMap, getNestedBottle.call(this, parts[0]));
        }
        removeProviderMap.call(this, originalProviderName);
        this.provider(originalProviderName, variable1[originalProviderName]);
    }, this);
}",Resets providers on a bottle instance . If names array is provided only the named providers will be reset .,Reset all of the bottle providers .,This function is called when the bottle is initialized .,1,Prediction1
"function rotatePersp(p, r) {
        return [
            p[ 0]*r[0], p[ 0]*r[1], p[ 0]*r[ 2],     0,
            p[ 5]*r[4], p[ 5]*r[5], p[ 5]*r[ 6],     0,
            p[10]*r[8], p[10]*r[9], p[10]*r[10], p[11],
                 -r[8],      -r[9],      -r[10],     0
        ];
    }","function func0(variable0, variable1) {
    return [
        variable0[0] * variable1[0],
        variable0[0] * variable1[1],
        variable0[0] * variable1[2],
        0,
        variable0[5] * variable1[4],
        variable0[5] * variable1[5],
        variable0[5] * variable1[6],
        0,
        variable0[10] * variable1[8],
        variable0[10] * variable1[9],
        variable0[10] * variable1[10],
        variable0[11],
        -variable1[8],
        -variable1[9],
        -variable1[10],
        0
    ];
}",Rotates perspective matrix .,Creates a 4 - by - 4 matrix from a 4 - by - 4 matrix,Returns an array with the result of multiplying the two variables,1,Prediction1
"function quality(str) {
  var parts = str.split(/ *; */),
      val = parts[0];

  var q = parts[1] ? parseFloat(parts[1].split(/ *= */)[1]) : 1;

  return { value: val, quality: q };
}","function func0(variable0) {
    var variable1 = variable0.split(/ *; */), variable2 = variable1[0];
    var variable3 = variable1[1] ? parseFloat(variable1[1].split(/ *= */)[1]) : 1;
    return {
        value: variable2,
        func0: variable3
    };
}",Parse quality str returning an object with . value and . quality .,Parse variable0 into variable2 and variable3,Parses a query string and returns an object with the value and func value .,0,Prediction2
"function getUnionSignatures(types, kind) {
            var signatureLists = ts.map(types, function (t) { return getSignaturesOfType(t, kind); });
            var result = undefined;
            for (var i = 0; i < signatureLists.length; i++) {
                for (var _i = 0, _a = signatureLists[i]; _i < _a.length; _i++) {
                    var signature = _a[_i];
                    // Only process signatures with parameter lists that aren't already in the result list
                    if (!result || !findMatchingSignature(result, signature, /*partialMatch*/ false, /*ignoreReturnTypes*/ true)) {
                        var unionSignatures = findMatchingSignatures(signatureLists, signature, i);
                        if (unionSignatures) {
                            var s = signature;
                            // Union the result types when more than one signature matches
                            if (unionSignatures.length > 1) {
                                s = cloneSignature(signature);
                                // Clear resolved return type we possibly got from cloneSignature
                                s.resolvedReturnType = undefined;
                                s.unionSignatures = unionSignatures;
                            }
                            (result || (result = [])).push(s);
                        }
                    }
                }
            }
            return result || emptyArray;
        }","function func0(variable0, variable1) {
    var variable2 = ts.map(variable0, function (t) {
        return getSignaturesOfType(t, variable1);
    });
    var variable3 = undefined;
    for (var i = 0; i < variable2.length; i++) {
        for (var _i = 0, _a = variable2[i]; _i < _a.length; _i++) {
            var variable4 = _a[_i];
            if (!variable3 || !findMatchingSignature(variable3, variable4, false, true)) {
                var unionSignatures = findMatchingSignatures(variable2, variable4, i);
                if (unionSignatures) {
                    var s = variable4;
                    if (unionSignatures.length > 1) {
                        s = cloneSignature(variable4);
                        s.resolvedReturnType = undefined;
                        s.unionSignatures = unionSignatures;
                    }
                    (variable3 || (variable3 = [])).push(s);
                }
            }
        }
    }
    return variable3 || emptyArray;
}",The signatures of a union type are those signatures that are present in each of the constituent types . Generic signatures must match exactly but non - generic signatures are allowed to have extra optional parameters and may differ in return types . When signatures differ in return types the resulting return type is the union of the constituent return types .,Returns an array of signatures that match variable0 to variable1,Returns the signatures of all types in a list of types .,0,Prediction2
"function getEmailGlobalInfo(callback, email) {
    if ((email===undefined)||(!email.length)){
        return callback(returnError('Empty email'));
    }
    sendRequest( 'emails/' + email, 'GET', {}, true, callback );
}","function func0(variable0, variable1) {
    if (variable1 === undefined || !variable1.length) {
        return variable0(returnError('Empty email'));
    }
    sendRequest('emails/' + variable1, 'GET', {}, true, variable0);
}",Get global information about email,Get an email,Get an email,1,Tie
"function processMessage(message) {
    var firstChar = message.charAt(0);
    if (firstChar == 'J') {
        // This is deprecated on the .java side. It doesn't work with CSP enabled.
        eval(message.slice(1));
    } else if (firstChar == 'S' || firstChar == 'F') {
        var success = firstChar == 'S';
        var keepCallback = message.charAt(1) == '1';
        var spaceIdx = message.indexOf(' ', 2);
        var status = +message.slice(2, spaceIdx);
        var nextSpaceIdx = message.indexOf(' ', spaceIdx + 1);
        var callbackId = message.slice(spaceIdx + 1, nextSpaceIdx);
        var payloadMessage = message.slice(nextSpaceIdx + 1);
        var payload = [];
        buildPayload(payload, payloadMessage);
        cordova.callbackFromNative(callbackId, success, status, payload, keepCallback);
    } else {
        console.log(""processMessage failed: invalid message: "" + JSON.stringify(message));
    }
}","function func0(variable0) {
    var variable1 = variable0.charAt(0);
    if (variable1 == 'J') {
        eval(variable0.slice(1));
    } else if (variable1 == 'S' || variable1 == 'F') {
        var success = variable1 == 'S';
        var keepCallback = variable0.charAt(1) == '1';
        var spaceIdx = variable0.indexOf(' ', 2);
        var status = +variable0.slice(2, spaceIdx);
        var nextSpaceIdx = variable0.indexOf(' ', spaceIdx + 1);
        var callbackId = variable0.slice(spaceIdx + 1, nextSpaceIdx);
        var payloadMessage = variable0.slice(nextSpaceIdx + 1);
        var payload = [];
        buildPayload(payload, payloadMessage);
        cordova.callbackFromNative(callbackId, success, status, payload, keepCallback);
    } else {
        console.log('processMessage failed: invalid message: ' + JSON.stringify(variable0));
    }
}",Processes a single message as encoded by NativeToJsMessageQueue . java .,Process a message,Process a message,0,Tie
"function unsubscribeFrom(sChannelId, sEventType, oSubscriber) {
  const aChannelEvents = _getChannelEvents(sChannelId, sEventType);
  for (let nEvent = aChannelEvents.length - 1; nEvent >= 0; nEvent--) {
    const oItem = aChannelEvents[nEvent];
    if (oItem.subscriber === oSubscriber) {
      aChannelEvents.splice(nEvent, 1);
    }
  }
}","function func0(variable0, variable1, variable2) {
    const variable3 = _getChannelEvents(variable0, variable1);
    for (let nEvent = variable3.length - 1; nEvent >= 0; nEvent--) {
        const variable4 = variable3[nEvent];
        if (variable4.subscriber === variable2) {
            variable3.splice(nEvent, 1);
        }
    }
}",Method to unsubscribe a subscriber from a channel and event type . It iterates in reverse order to avoid messing with array length when removing items .,Remove a subscriber from a channel,Remove a subscriber from a channel .,0,Tie
"function createBasicPlugin(name, plugin) {
  var basicPluginWrapper = function basicPluginWrapper() {

    // We trigger the ""beforepluginsetup"" and ""pluginsetup"" events on the player
    // regardless, but we want the hash to be consistent with the hash provided
    // for advanced plugins.
    //
    // The only potentially counter-intuitive thing here is the `instance` in
    // the ""pluginsetup"" event is the value returned by the `plugin` function.
    triggerSetupEvent(this, { name: name, plugin: plugin, instance: null }, true);

    var instance = plugin.apply(this, arguments);

    markPluginAsActive(this, name);
    triggerSetupEvent(this, { name: name, plugin: plugin, instance: instance });

    return instance;
  };

  Object.keys(plugin).forEach(function (prop) {
    basicPluginWrapper[prop] = plugin[prop];
  });

  return basicPluginWrapper;
}","function func0(variable0, variable1) {
    var variable2 = function variable2() {
        triggerSetupEvent(this, {
            variable0: variable0,
            variable1: variable1,
            instance: null
        }, true);
        var instance = variable1.apply(this, arguments);
        markPluginAsActive(this, variable0);
        triggerSetupEvent(this, {
            variable0: variable0,
            variable1: variable1,
            instance: instance
        });
        return instance;
    };
    Object.keys(variable1).forEach(function (prop) {
        variable2[prop] = variable1[prop];
    });
    return variable2;
}",Takes a basic plugin function and returns a wrapper function which marks on the player that the plugin has been activated .,Creates a function that can be used to create a new instance of a plugin .,Creates a new instance of a plugin .,0,Tie
"function factory(list) {
  var expressions = []
  var sensitive = []
  var insensitive = []

  construct()

  return test

  function construct() {
    var length = list.length
    var index = -1
    var value
    var normal

    while (++index < length) {
      value = list[index]
      normal = value === lower(value)

      if (value.charAt(value.length - 1) === '*') {
        // Regexes are insensitive now, once we need them this should check for
        // `normal` as well.
        expressions.push(new RegExp('^' + value.slice(0, -1), 'i'))
      } else if (normal) {
        insensitive.push(value)
      } else {
        sensitive.push(value)
      }
    }
  }

  function test(value) {
    var normal = lower(value)
    var length
    var index

    if (sensitive.indexOf(value) !== -1 || insensitive.indexOf(normal) !== -1) {
      return true
    }

    length = expressions.length
    index = -1

    while (++index < length) {
      if (expressions[index].test(value)) {
        return true
      }
    }

    return false
  }
}","function func0(variable0) {
    var variable1 = [];
    var variable2 = [];
    var variable3 = [];
    func1();
    return func2;
    function func1() {
        var variable4 = variable0.variable4;
        var variable5 = -1;
        var variable6;
        var variable7;
        while (++variable5 < variable4) {
            variable6 = variable0[variable5];
            variable7 = variable6 === lower(variable6);
            if (variable6.charAt(variable6.variable4 - 1) === '*') {
                variable1.push(new RegExp('^' + variable6.slice(0, -1), 'i'));
            } else if (variable7) {
                variable3.push(variable6);
            } else {
                variable2.push(variable6);
            }
        }
    }
    function func2(variable6) {
        var variable7 = lower(variable6);
        var variable4;
        var variable5;
        if (variable2.indexOf(variable6) !== -1 || variable3.indexOf(variable7) !== -1) {
            return true;
        }
        variable4 = variable1.variable4;
        variable5 = -1;
        while (++variable5 < variable4) {
            if (variable1[variable5].func2(variable6)) {
                return true;
            }
        }
        return false;
    }
}",Create a test based on a list of phrases .,Returns a function that returns true if the variable0 is a regular expression and false otherwise .,Creates a function that returns a function that returns true if any of the strings in the array contains any of the patterns that match the pattern .,0,Prediction2
"function GNTP(type, opts) {
        opts = opts || {};
        this.type = type;
        this.host = opts.host || 'localhost';
        this.port = opts.port || 23053;
        this.request = 'GNTP/1.0 ' + type + ' NONE' + nl;
        this.resources = [];
        this.attempts = 0;
        this.maxAttempts = 5;
    }","function func0(variable0, variable1) {
    variable1 = variable1 || {};
    this.variable0 = variable0;
    this.host = variable1.host || 'localhost';
    this.port = variable1.port || 23053;
    this.request = 'GNTP/1.0 ' + variable0 + ' NONE' + nl;
    this.resources = [];
    this.attempts = 0;
    this.maxAttempts = 5;
}",Create a new GNTP request of the given type .,Creates a new GNTP function,Creates a new GNTP instance .,0,Tie
"function registerOAuth2 (providerName, Strategy) {
    registerProvider(providerName, function (credentials, passport, authHandler) {
      passport.use(new Strategy(credentials,
        function (req, accessToken, refreshToken, profile, done) {
          authHandler(req, providerName, {accessToken: accessToken, refreshToken: refreshToken}, profile)
            .asCallback(done);
        }
      ));
    });
  }","function func0(variable0, variable1) {
    registerProvider(variable0, function (credentials, passport, authHandler) {
        passport.use(new variable1(credentials, function (req, accessToken, refreshToken, profile, done) {
            authHandler(req, variable0, {
                accessToken: accessToken,
                refreshToken: refreshToken
            }, profile).asCallback(done);
        }));
    });
}",A shortcut to register OAuth2 providers that follow the exact accessToken refreshToken pattern .,Register a new provider .,Register a provider to passport,1,Tie
"function main() {
    return __awaiter(this, void 0, void 0, function () {
        var outputDataSize, interval, dataFrame, dateFormat, api;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    outputDataSize = ""compact"";
                    if (argv.outputDataSize) {
                        outputDataSize = argv.outputDataSize;
                    }
                    interval = '60min';
                    if (argv.interval) {
                        interval = argv.interval;
                    }
                    api = new index_1.AlphaVantageAPI(argv.apiKey, outputDataSize, argv.verbose);
                    if (!(argv.type === 'daily')) return [3 /*break*/, 2];
                    return [4 /*yield*/, api.getDailyDataFrame(argv.symbol)];
                case 1:
                    dataFrame = _a.sent();
                    dateFormat = 'YYYY-MM-DD';
                    return [3 /*break*/, 5];
                case 2:
                    if (!(argv.type === 'intraday')) return [3 /*break*/, 4];
                    return [4 /*yield*/, api.getIntradayDataFrame(argv.symbol, interval)];
                case 3:
                    dataFrame = _a.sent();
                    dateFormat = ""YYYY-MM-DD HH:mm:ss"";
                    return [3 /*break*/, 5];
                case 4: throw new Error(""Unexpected data type: "" + argv.type + "", expected it to be either 'daily' or 'intrday'"");
                case 5:
                    if (!argv.verbose) {
                        console.log('>> ' + argv.out);
                    }
                    dataFrame
                        .transformSeries({
                        Timestamp: function (t) { return moment(t).format(dateFormat); },
                    })
                        .asCSV()
                        .writeFileSync(argv.out);
                    return [2 /*return*/];
            }
        });
    });
}","function func0() {
    return __awaiter(this, void 0, void 0, function () {
        var outputDataSize, interval, dataFrame, dateFormat, api;
        return __generator(this, function (_a) {
            switch (_a.label) {
            case 0:
                outputDataSize = 'compact';
                if (argv.outputDataSize) {
                    outputDataSize = argv.outputDataSize;
                }
                interval = '60min';
                if (argv.interval) {
                    interval = argv.interval;
                }
                api = new index_1.AlphaVantageAPI(argv.apiKey, outputDataSize, argv.verbose);
                if (!(argv.type === 'daily'))
                    return [
                        3,
                        2
                    ];
                return [
                    4,
                    api.getDailyDataFrame(argv.symbol)
                ];
            case 1:
                dataFrame = _a.sent();
                dateFormat = 'YYYY-MM-DD';
                return [
                    3,
                    5
                ];
            case 2:
                if (!(argv.type === 'intraday'))
                    return [
                        3,
                        4
                    ];
                return [
                    4,
                    api.getIntradayDataFrame(argv.symbol, interval)
                ];
            case 3:
                dataFrame = _a.sent();
                dateFormat = 'YYYY-MM-DD HH:mm:ss';
                return [
                    3,
                    5
                ];
            case 4:
                throw new Error('Unexpected data type: ' + argv.type + ', expected it to be either \'daily\' or \'intrday\'');
            case 5:
                if (!argv.verbose) {
                    console.log('>> ' + argv.out);
                }
                dataFrame.transformSeries({
                    Timestamp: function (t) {
                        return moment(t).format(dateFormat);
                    }
                }).asCSV().writeFileSync(argv.out);
                return [2];
            }
        });
    });
}",Entry point .,Get data frames from the alpha vantage API,Get data frame from alpha vantage API,1,Tie
"function whenRead (args) {
    let value = getValue(args)
    if (value && typeof value.then === 'function') {
      value.then((val) => whenTest(args, val)).catch((error) => {
        console.error(`${action.displayName} caught an error whilst getting a value to test`, error)
      })
    } else {
      whenTest(args, value)
    }
  }","function func0(variable0) {
    let variable1 = getValue(variable0);
    if (variable1 && typeof variable1.then === 'function') {
        variable1.then(val => whenTest(variable0, val)).catch(error => {
            console.error(`${ action.displayName } caught an error whilst getting a value to test`, error);
        });
    } else {
        whenTest(variable0, variable1);
    }
}",define the action,Get the value to test,This function is called when the value of the variable0 is set to true,1,Prediction1
"function TextTrackCueList(cues) {
    classCallCheck(this, TextTrackCueList);

    var list = this; // eslint-disable-line

    if (IS_IE8) {
      list = document.createElement('custom');

      for (var prop in TextTrackCueList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = TextTrackCueList.prototype[prop];
        }
      }
    }

    TextTrackCueList.prototype.setCues_.call(list, cues);

    /**
     * @memberof TextTrackCueList
     * @member {number} length
     *         The current number of `TextTrackCue`s in the TextTrackCueList.
     * @instance
     */
    Object.defineProperty(list, 'length', {
      get: function get$$1() {
        return this.length_;
      }
    });

    if (IS_IE8) {
      return list;
    }
  }","function func0(variable0) {
    classCallCheck(this, func0);
    var variable1 = this;
    if (IS_IE8) {
        variable1 = document.createElement('custom');
        for (var prop in func0.prototype) {
            if (prop !== 'constructor') {
                variable1[prop] = func0.prototype[prop];
            }
        }
    }
    func0.prototype.setCues_.call(variable1, variable0);
    Object.defineProperty(variable1, 'length', {
        get: function get$$1() {
            return this.length_;
        }
    });
    if (IS_IE8) {
        return variable1;
    }
}",Create an instance of this class ..,Creates a new Cues object .,Creates a new instance of func0 .,1,Prediction1
"function run(context, fn, finish, args) {
	// Argument mangling {{{
	if (typeof context == 'function') { // called as run(fn, finish, args);
		args = finish;
		finish = fn;
		fn = context;
		context = this;
	}
	// }}}

	if (isPromise(fn)) { // Given a promise that has already resolved?
		fn
			.then(function(value) {
				finish.apply(context, [null, value]);
			})
			.catch(function(err) {
				finish.call(context, err || 'An error occured');
			});
	} else if (hasCallback(fn)) { // Callback w/ (err, result) pattern
		var result = fn.apply(context, args ? [finish].concat(args) : [finish]);
		if (isPromise(result)) {
			result
				.then(function(value) { // Remap result from (val) => (err, val)
					finish.apply(context, [null, value]);
				})
				.catch(function(err) {
					finish.call(context, err || 'An error occured');
				});
		}
	} else { // Maybe either a promise or sync function?
		var result;
		try {
			result = fn.apply(context, args || []); // Run the function and see what it gives us
		} catch (e) {
			finish.call(context, e);
		}
		if (isPromise(result)) { // Got back a promise - attach to the .then() function
			result
				.then(function(value) { // Remap result from (val) => (err, val)
					finish.apply(context, [null, value]);
				})
				.catch(function(err) {
					finish.call(context, err || 'An error occured');
				});
		} else { // Didn't provide back a promise - assume it was a sync function
			finish.apply(context, [null, result]);
		}
	}
}","function func0(variable0, variable1, variable2, variable3) {
    if (typeof variable0 == 'function') {
        variable3 = variable2;
        variable2 = variable1;
        variable1 = variable0;
        variable0 = this;
    }
    if (isPromise(variable1)) {
        variable1.then(function (value) {
            variable2.apply(variable0, [
                null,
                value
            ]);
        }).catch(function (err) {
            variable2.call(variable0, err || 'An error occured');
        });
    } else if (hasCallback(variable1)) {
        var result = variable1.apply(variable0, variable3 ? [variable2].concat(variable3) : [variable2]);
        if (isPromise(result)) {
            result.then(function (value) {
                variable2.apply(variable0, [
                    null,
                    value
                ]);
            }).catch(function (err) {
                variable2.call(variable0, err || 'An error occured');
            });
        }
    } else {
        var result;
        try {
            result = variable1.apply(variable0, variable3 || []);
        } catch (e) {
            variable2.call(variable0, e);
        }
        if (isPromise(result)) {
            result.then(function (value) {
                variable2.apply(variable0, [
                    null,
                    value
                ]);
            }).catch(function (err) {
                variable2.call(variable0, err || 'An error occured');
            });
        } else {
            variable2.apply(variable0, [
                null,
                result
            ]);
        }
    }
}",Run a single function promise return promise factory or any other combination - then a callback when finished Take a function reference and treat it as a callback style function If the function returns a promise this behaviour is transformed into a callback style function,Execute a function in a context .,Calls variable1 with variable2 and variable3 . If variable2 is a function it will call variable2 with variable3 .,1,Prediction1
"function convertPatternGroupToTask(base, positive, negative, dynamic) {
    return {
        base: base,
        dynamic: dynamic,
        patterns: [].concat(positive, negative.map(patternUtils.convertToNegativePattern)),
        positive: positive,
        negative: negative
    };
}","function func0(variable0, variable1, variable2, variable3) {
    return {
        variable0: variable0,
        variable3: variable3,
        patterns: [].concat(variable1, variable2.map(patternUtils.convertToNegativePattern)),
        variable1: variable1,
        variable2: variable2
    };
}",Create a task for positive and negative patterns .,Creates a new pattern object .,Creates a function that takes a variable0 and a variable1 and a variable2 and a variable3 and returns a function that takes a variable0 and a variable1 and a variable2 array .,1,Prediction1
"function addTypesToSet(typeSet, types, typeSetKind) {
            for (var _i = 0; _i < types.length; _i++) {
                var type = types[_i];
                addTypeToSet(typeSet, type, typeSetKind);
            }
        }","function func0(variable0, variable1, variable2) {
    for (var _i = 0; _i < variable1.length; _i++) {
        var variable3 = variable1[_i];
        addTypeToSet(variable0, variable3, variable2);
    }
}",Add the given types to the given type set . Order is preserved duplicates are removed and nested types of the given kind are flattened into the set .,Creates a function that sets the type of variable0 to variable1,Sets the types of a list of types to the given object .,0,Prediction2
"function writePackageManifest (packageName) {
  const packagePath = require.resolve(packageName + '/package.json')
  let { name, main, author, license, types, typings } = require(packagePath)
  if (!main) {
    main = 'index.js'
  }

  let typesFile = types || typings
  if (typesFile) {
    typesFile = require.resolve(join(packageName, typesFile))
  }

  const compiledPackagePath = join(__dirname, `dist/compiled/${packageName}`)

  const potentialLicensePath = join(dirname(packagePath), './LICENSE')
  if (existsSync(potentialLicensePath)) {
    this._.files.push({
      dir: compiledPackagePath,
      base: 'LICENSE',
      data: readFileSync(potentialLicensePath, 'utf8')
    })
  }

  this._.files.push({
    dir: compiledPackagePath,
    base: 'package.json',
    data:
      JSON.stringify(
        Object.assign(
          {},
          { name, main: `${basename(main, '.' + extname(main))}` },
          author ? { author } : undefined,
          license ? { license } : undefined,
          typesFile
            ? {
              types: relative(compiledPackagePath, typesFile)
            }
            : undefined
        )
      ) + '\n'
  })
}","function func0(variable0) {
    const variable1 = require.resolve(variable0 + '/package.json');
    let {name, main, author, license, types, typings} = require(variable1);
    if (!main) {
        main = 'index.js';
    }
    let variable2 = types || typings;
    if (variable2) {
        variable2 = require.resolve(join(variable0, variable2));
    }
    const variable3 = join(__dirname, `dist/compiled/${ variable0 }`);
    const variable4 = join(dirname(variable1), './LICENSE');
    if (existsSync(variable4)) {
        this._.files.push({
            dir: variable3,
            base: 'LICENSE',
            data: readFileSync(variable4, 'utf8')
        });
    }
    this._.files.push({
        dir: variable3,
        base: 'package.json',
        data: JSON.stringify(Object.assign({}, {
            name,
            main: `${ basename(main, '.' + extname(main)) }`
        }, author ? { author } : undefined, license ? { license } : undefined, variable2 ? { types: relative(variable3, variable2) } : undefined)) + '\n'
    });
}",This function writes a minimal package . json file for a compiled package . It defines name main author and license . It also defines types . n . b . types intended for development usage only .,This function is the main function of the compiler .,Add a package . json file to the compiler .,0,Prediction2
"function getBaseParams(params, base) {
  if (typeof base !== 'string') {
    throw new Error(`Invalid repository name in key ""${BASE_KEY}""`);
  }

  const match = base.match(BASE_REGEX);
  if (match == null) {
    throw new Error(`Invalid repository name in key ""${BASE_KEY}"": ${base}`);
  }

  return {
    owner: match[1] || params.owner,
    repo: match[2],
    path: match[3] || params.path,
  };
}","function func0(variable0, variable1) {
    if (typeof variable1 !== 'string') {
        throw new Error(`Invalid repository name in key ""${ BASE_KEY }""`);
    }
    const variable2 = variable1.variable2(BASE_REGEX);
    if (variable2 == null) {
        throw new Error(`Invalid repository name in key ""${ BASE_KEY }"": ${ variable1 }`);
    }
    return {
        owner: variable2[1] || variable0.owner,
        repo: variable2[2],
        path: variable2[3] || variable0.path
    };
}",Computes parameters for the repository specified in base,Create a repository object from variable0 and variable1,Parses a repository name into a repository object .,0,Prediction2
"function campaignStatByCountries(callback,id){
    if (id===undefined) {
        return callback(returnError('Empty book id'));
    }
    sendRequest( 'campaigns/' + id + '/countries', 'GET', {}, true, callback );
}","function func0(variable0, variable1) {
    if (variable1 === undefined) {
        return variable0(returnError('Empty book id'));
    }
    sendRequest('campaigns/' + variable1 + '/countries', 'GET', {}, true, variable0);
}",Get campaign statistic by countries,Get countries for a book,Get the countries for a book,0,Tie
"function startWatching(opts) {
    var chokidarOpts = createChokidarOpts(opts);
    var watcher = chokidar.watch(opts.patterns, chokidarOpts);

    var throttledRun = _.throttle(run, opts.throttle);
    var debouncedRun = _.debounce(throttledRun, opts.debounce);
    watcher.on('all', function(event, path) {
        var description = EVENT_DESCRIPTIONS[event] + ':';

        if (opts.verbose) {
            console.error(description, path);
        } else {
            if (!opts.silent) {
                console.log(event + ':' + path);
            }
        }

        // XXX: commands might be still run concurrently
        if (opts.command) {
            debouncedRun(
                opts.command
                    .replace(/\{path\}/ig, path)
                    .replace(/\{event\}/ig, event)
            );
        }
    });

    watcher.on('error', function(error) {
        console.error('Error:', error);
        console.error(error.stack);
    });

    watcher.once('ready', function() {
        var list = opts.patterns.join('"", ""');
        if (!opts.silent) {
            console.error('Watching', '""' + list + '"" ..');
        }
    });
}","function func0(variable0) {
    var variable1 = createChokidarOpts(variable0);
    var variable2 = chokidar.watch(variable0.patterns, variable1);
    var variable3 = _.throttle(run, variable0.throttle);
    var variable4 = _.debounce(variable3, variable0.debounce);
    variable2.on('all', function (event, path) {
        var description = EVENT_DESCRIPTIONS[event] + ':';
        if (variable0.verbose) {
            console.error(description, path);
        } else {
            if (!variable0.silent) {
                console.log(event + ':' + path);
            }
        }
        if (variable0.command) {
            variable4(variable0.command.replace(/\{path\}/ig, path).replace(/\{event\}/ig, event));
        }
    });
    variable2.on('error', function (error) {
        console.error('Error:', error);
        console.error(error.stack);
    });
    variable2.once('ready', function () {
        var list = variable0.patterns.join('"", ""');
        if (!variable0.silent) {
            console.error('Watching', '""' + list + '"" ..');
        }
    });
}",Estimates spent working hours based on commit dates,Watches for changes .,Run chokidar with variable0,1,Prediction1
"function allSettled(promises) {
    ""use strict"";
    const wrappedPromises = promises.map((curPromise) => curPromise.reflect());
    return Promise.all(wrappedPromises);
}","function func0(variable0) {
    'use strict';
    const variable1 = variable0.map(curPromise => curPromise.reflect());
    return Promise.all(variable1);
}",Creates a promise that is resolved when all input promises have been settled . The returned Promise is resolved with an array of Promise . Inspection objects .,reflects a list of promises,function 0 - > Promise . all,1,Prediction1
"function getMarkupSnippets(registry, config) {
	return registry.all({ type: 'string' }).map(snippet => ({
		key: snippet.key,
		value: snippet.value,
		preview: removeFields(expand(snippet.value, config)),
		snippet: snippet.key
	}));
}","function func0(variable0, variable1) {
    return variable0.all({ type: 'string' }).map(snippet => ({
        key: snippet.key,
        value: snippet.value,
        preview: removeFields(expand(snippet.value, variable1)),
        snippet: snippet.key
    }));
}",Returns markup snippets list,Function to expand variable0 with variable1,Get a list of strings from a JSON document .,0,Prediction2
"function load(images){
		def = Deferred();
		
		/**
		 * Check if the images is img objects or image src
		 * return string of src
		 */
		srcs = convertImagesToSrc(images);

		/**
		 * Loop through src's and load image
		 */
		for (var i = 0; i < srcs.length; i++) {
			imageloader.load(srcs[i])
			.success(function(img){

				/** call imageloaded a pass the img that is loaded */
				imageLoaded(img);
			})
			.error(function(msg){
				def.reject(msg + ' couldn\'t be loaded');
			});
		};
		return def.promise;
	}","function func0(variable0) {
    def = Deferred();
    srcs = convertImagesToSrc(variable0);
    for (var i = 0; i < srcs.length; i++) {
        imageloader.func0(srcs[i]).success(function (img) {
            imageLoaded(img);
        }).error(function (msg) {
            def.reject(msg + ' couldn\'t be loaded');
        });
    }
    ;
    return def.promise;
}",Load a collection of images,call the imageloader function,Load a list of images,0,Prediction2
"function mergeProperty(destination, source, property) {
    if (source[property] instanceof Array) {
        mergeAsArray(destination, source, property);
    }
    else if (isPrimitive(source[property]) || !isLiteral(source[property])) {
        overrideIfNotExists(destination, source, property);
    }
    else {
        mergeAsObject(destination, source, property);
    }
}","function func0(variable0, variable1, variable2) {
    if (variable1[variable2] instanceof Array) {
        mergeAsArray(variable0, variable1, variable2);
    } else if (isPrimitive(variable1[variable2]) || !isLiteral(variable1[variable2])) {
        overrideIfNotExists(variable0, variable1, variable2);
    } else {
        mergeAsObject(variable0, variable1, variable2);
    }
}",Merge a single property,Merge a value into an object .,Merge variable0 with variable1 with variable2,1,Prediction1
"function checkToMove(contextControl, targetControl) {
    var elements = contextControl.find('.transfer-group').find('input:checked')
    var sourceTag = $(elements).closest('.form-check')

    $(elements).each(function() {
      $(this).prop('checked', false)
      $(sourceTag)
        .detach()
        .appendTo(targetControl)
        .addClass('added')
    })
  }","function func0(variable0, variable1) {
    var variable2 = variable0.find('.transfer-group').find('input:checked');
    var variable3 = $(variable2).closest('.form-check');
    $(variable2).each(function () {
        $(this).prop('checked', false);
        $(variable3).detach().appendTo(variable1).addClass('added');
    });
}",elementi da aggiungere,Remove all inputs from the transfer group .,This function is called when the user clicks on a radio button,1,Prediction1
"function KeystoneClient(url, options) {
  options = options || {};

  if (options.username) {
    if (!options.password && !options.apiKey) {
      throw new Error('If username is provided you also need to provide password or apiKey');
    }
  }

  this._url = url;
  this._username = options.username;
  this._apiKey = options.apiKey;
  this._password = options.password;
  this._extraArgs = options.extraArgs || {};
  this._cacheTokenFor = options.cacheTokenFor || DEFAULT_CACHE_TOKEN_FOR;

  this._token = null;
  this._tokenExpires = null;
  this._refreshTokenCompletions = [];
  this._tokenUpdated = 0;
  this._tenantId = null;
  this._serviceCatalog = [];
}","function func0(variable0, variable1) {
    variable1 = variable1 || {};
    if (variable1.username) {
        if (!variable1.password && !variable1.apiKey) {
            throw new Error('If username is provided you also need to provide password or apiKey');
        }
    }
    this._url = variable0;
    this._username = variable1.username;
    this._apiKey = variable1.apiKey;
    this._password = variable1.password;
    this._extraArgs = variable1.extraArgs || {};
    this._cacheTokenFor = variable1.cacheTokenFor || DEFAULT_CACHE_TOKEN_FOR;
    this._token = null;
    this._tokenExpires = null;
    this._refreshTokenCompletions = [];
    this._tokenUpdated = 0;
    this._tenantId = null;
    this._serviceCatalog = [];
}",OpenStack Keystone Identity API client .,Creates a new Client instance .,Creates a new instance of func0,1,Prediction1
"function filter(arr, cb) {
  if (arr == null) return [];
  if (typeof cb !== 'function') {
    throw new TypeError('braces: filter expects a callback function.');
  }

  var len = arr.length;
  var res = arr.slice();
  var i = 0;

  while (len--) {
    if (!cb(arr[len], i++)) {
      res.splice(len, 1);
    }
  }
  return res;
}","function func0(variable0, variable1) {
    if (variable0 == null)
        return [];
    if (typeof variable1 !== 'function') {
        throw new TypeError('braces: filter expects a callback function.');
    }
    var variable2 = variable0.length;
    var variable3 = variable0.slice();
    var variable4 = 0;
    while (variable2--) {
        if (!variable1(variable0[variable2], variable4++)) {
            variable3.splice(variable2, 1);
        }
    }
    return variable3;
}",Fast array filter,Returns a copy of variable0 that does not match variable1 .,The base implementation of _ . filter without support for callback shorthands .,0,Prediction2
"function mapImageResources(rootDir, subDir, type, resourceName) {
    var pathMap = {};
    shell.ls(path.join(rootDir, subDir, type + '-*'))
    .forEach(function (drawableFolder) {
        var imagePath = path.join(subDir, path.basename(drawableFolder), resourceName);
        pathMap[imagePath] = null;
    });
    return pathMap;
}","function func0(variable0, variable1, variable2, variable3) {
    var variable4 = {};
    shell.ls(path.join(variable0, variable1, variable2 + '-*')).forEach(function (drawableFolder) {
        var imagePath = path.join(variable1, path.basename(drawableFolder), variable3);
        variable4[imagePath] = null;
    });
    return variable4;
}",Gets a map containing resources of a specified name from all drawable folders in a directory .,Get the list of all drawable folders .,Returns an object with all the images in the specified folder,1,Prediction1
"function startDecelAnim() {
            var firstPoint = trackingPoints[0];
            var lastPoint = trackingPoints[trackingPoints.length - 1];

            var xOffset = lastPoint.x - firstPoint.x;
            var yOffset = lastPoint.y - firstPoint.y;
            var timeOffset = lastPoint.time - firstPoint.time;

            var D = timeOffset / 15 / multiplier;

            decVelX = xOffset / D || 0; // prevent NaN
            decVelY = yOffset / D || 0;

            var diff = checkBounds();

            if (Math.abs(decVelX) > 1 || Math.abs(decVelY) > 1 || !diff.inBounds) {
                decelerating = true;
                requestAnimFrame(stepDecelAnim);
            }
        }","function func0() {
    var variable0 = trackingPoints[0];
    var variable1 = trackingPoints[trackingPoints.length - 1];
    var variable2 = variable1.x - variable0.x;
    var variable3 = variable1.y - variable0.y;
    var variable4 = variable1.time - variable0.time;
    var variable5 = variable4 / 15 / multiplier;
    decVelX = variable2 / variable5 || 0;
    decVelY = variable3 / variable5 || 0;
    var variable6 = checkBounds();
    if (Math.abs(decVelX) > 1 || Math.abs(decVelY) > 1 || !variable6.inBounds) {
        decelerating = true;
        requestAnimFrame(stepDecelAnim);
    }
}",Initialize animation of values coming to a stop,Decelerating function,step the decelerating animation,0,Prediction2
"function getIndexOfPrimitive(primitive, array, startingPosition) {
    if (startingPosition === void 0) { startingPosition = 0; }
    errorIfNotPrimitive_1.errorIfNotPrimitive(primitive);
    error_if_not_populated_array_1.errorIfNotPopulatedArray(array);
    errorIfNotInteger_1.errorIfNotInteger(startingPosition);
    return array.indexOf(primitive, startingPosition);
}","function func0(variable0, variable1, variable2) {
    if (variable2 === void 0) {
        variable2 = 0;
    }
    errorIfNotPrimitive_1.errorIfNotPrimitive(variable0);
    error_if_not_populated_array_1.errorIfNotPopulatedArray(variable1);
    errorIfNotInteger_1.errorIfNotInteger(variable2);
    return variable1.indexOf(variable0, variable2);
}",According to tests this error - checking does not slow down execution . It s not necessary to worry about repetitive error - checking slowing down execution when this function is called inside a loop .,Gets the index of a value in an array .,Returns the index of variable0 in variable1,1,Prediction1
"function currentTreeRootSecondChildExcludingDragging() {
      var _this = this;

      return this.currentTree.rootData.children.slice(0, 3).filter(function (v) {
        return v !== _this.node;
      })[1];
    }","function func0() {
    var variable0 = this;
    return this.currentTree.rootData.children.slice(0, 3).filter(function (v) {
        return v !== variable0.node;
    })[1];
}",the second child of currentTree root excluding dragging node,Get the root node of the current node .,Returns the name of the first node in the tree .,1,Prediction1
"function hasChanged(previousState, newState, filepath) {
    const previouslyExists = exists(previousState, filepath);
    const newExists = exists(newState, filepath);
    if (!previouslyExists && !newExists) {
        // Still non existing
        return false;
    } else if (exists(previousState, filepath) !== exists(newState, filepath)) {
        // The file is absent from one
        return true;
    } else {
        // Both files exist
        const prevWorking = previousState.getCurrentState();
        const newWorking = newState.getCurrentState();

        const prevSha = WorkingUtils.findSha(prevWorking, filepath);
        const newSha = WorkingUtils.findSha(newWorking, filepath);
        if (prevSha === null && newSha === null) {
            // Both have are in pending changes. We can compare their contents
            return read(previousState, filepath).getAsString() !==
                read(newState, filepath).getAsString();
        } else {
            // Content changed if Shas are different, or one of them is null
            return prevSha !== newSha;
        }
    }
}","function func0(variable0, variable1, variable2) {
    const variable3 = exists(variable0, variable2);
    const variable4 = exists(variable1, variable2);
    if (!variable3 && !variable4) {
        return false;
    } else if (exists(variable0, variable2) !== exists(variable1, variable2)) {
        return true;
    } else {
        const prevWorking = variable0.getCurrentState();
        const newWorking = variable1.getCurrentState();
        const prevSha = WorkingUtils.findSha(prevWorking, variable2);
        const newSha = WorkingUtils.findSha(newWorking, variable2);
        if (prevSha === null && newSha === null) {
            return read(variable0, variable2).getAsString() !== read(variable1, variable2).getAsString();
        } else {
            return prevSha !== newSha;
        }
    }
}",Returns true if the given file has the same content in both RepositoryState s current working state or is absent from both .,Check if two files are the same .,Returns true if variable0 != variable1,1,Prediction1
"function lintString(sourceCode, userConfig, errorReporter, fileName) {
    let lintErrors, fixesApplied;

    try {
        if (userConfig.options.autofix || userConfig.options.autofixDryrun) {
            let result = solium.lintAndFix(sourceCode, userConfig);

            lintErrors = result.errorMessages;
            if (userConfig.options.autofix) {
                applyFixes(fileName, result);
                fixesApplied = result.fixesApplied;
            } else {
                errorReporter.reportDiff(fileName,
                    sourceCode, result.fixedSourceCode, result.fixesApplied.length);
            }
        } else {
            lintErrors = solium.lint(sourceCode, userConfig);
        }
    } catch (e) {
        // Don't abort in case of a parse error, just report it as a normal lint issue.
        if (e.name !== ""SyntaxError"") {
            const messageOrStackrace = userConfig.options.debug ? e.stack : e.message;
            errorReporter.reportFatal(`An error occured while linting over ${fileName}:${EOL}${messageOrStackrace}`);
            process.exit(errorCodes.ERRORS_FOUND);
        }

        lintErrors = [{
            ruleName: """",
            type: ""error"",
            message: `Syntax error: unexpected token ${e.found}`,
            line: e.location.start.line,
            column: e.location.start.column
        }];
    }

    // If any lint/internal errors/warnings exist, report them
    lintErrors.length &&
        errorReporter.report(fileName, sourceCode, lintErrors, fixesApplied);

    return lintErrors.reduce(function(numOfErrors, err) {
        return err.type === ""error"" ? numOfErrors+1 : numOfErrors;
    }, 0);
}","function func0(variable0, variable1, variable2, variable3) {
    let variable4, variable5;
    try {
        if (variable1.options.autofix || variable1.options.autofixDryrun) {
            let result = solium.lintAndFix(variable0, variable1);
            variable4 = result.errorMessages;
            if (variable1.options.autofix) {
                applyFixes(variable3, result);
                variable5 = result.variable5;
            } else {
                variable2.reportDiff(variable3, variable0, result.fixedSourceCode, result.variable5.length);
            }
        } else {
            variable4 = solium.lint(variable0, variable1);
        }
    } catch (e) {
        if (e.name !== 'SyntaxError') {
            const messageOrStackrace = variable1.options.debug ? e.stack : e.message;
            variable2.reportFatal(`An error occured while linting over ${ variable3 }:${ EOL }${ messageOrStackrace }`);
            process.exit(errorCodes.ERRORS_FOUND);
        }
        variable4 = [{
                ruleName: '',
                type: 'error',
                message: `Syntax error: unexpected token ${ e.found }`,
                line: e.location.start.line,
                column: e.location.start.column
            }];
    }
    variable4.length && variable2.report(variable3, variable0, variable4, variable5);
    return variable4.reduce(function (numOfErrors, err) {
        return err.type === 'error' ? numOfErrors + 1 : numOfErrors;
    }, 0);
}",Lint a source code string based on user settings . If autofix is enabled write the fixed code back to file .,Lint the given source code with the given options .,Lints variable0 with variable1 with variable2 with variable3,1,Prediction1
"function parseJSON(input, callback) {
  var error
  var result
  try {
    result = JSON.parse(input) }
  catch (e) {
    error = e }
  callback(error, result) }","function func0(variable0, variable1) {
    var variable2;
    var variable3;
    try {
        variable3 = JSON.parse(variable0);
    } catch (e) {
        variable2 = e;
    }
    variable1(variable2, variable3);
}",JSON . parse wrapped to take an errback .,Function to call variable0 with variable1 and variable2,Parses a JSON string into an object .,0,Prediction2
"function handleResponse(res, data, callback) {
    // HTTP 204 doesn't have a response
    var json = data && JSON.parse(data) || {};

    if ((res.statusCode >= 200) && (res.statusCode <= 206)) {
        // Handle a few known responses
        switch (json.message) {
            case 'Bad credentials':
                callback.call(this, json);
                break;

            default:
                callback.call(this, null, json);
        }
    } else {
        callback.call(this, json);
    }
}","function func0(variable0, variable1, variable2) {
    var variable3 = variable1 && JSON.parse(variable1) || {};
    if (variable0.statusCode >= 200 && variable0.statusCode <= 206) {
        switch (variable3.message) {
        case 'Bad credentials':
            variable2.call(this, variable3);
            break;
        default:
            variable2.call(this, null, variable3);
        }
    } else {
        variable2.call(this, variable3);
    }
}",Private method that handles HTTP responses we get from GitHub . This method will always be executed in the context of a GrelRequest .,This function is called when a request is received from the server,Handle the response from the server .,0,Prediction2
"function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}","function func0(variable0) {
    var variable1 = new Axios(variable0);
    var variable2 = bind(Axios.prototype.request, variable1);
    utils.extend(variable2, Axios.prototype, variable1);
    utils.extend(variable2, variable1);
    return variable2;
}",Create an instance of Axios,A function that returns an object that can be passed to Axios . request .,Creates a new instance of Axios .,0,Prediction2
"function processUri(src) {
    // Collapse double slashes (File plugin issue): ms-appdata:///temp//recs/memos/media.m4a => ms-appdata:///temp/recs/memos/media.m4a
    src = src.replace(/([^\/:])(\/\/)([^\/])/g, '$1/$3');

    // Remove beginning slashes
    src = src.replace(/^[\\\/]{1,2}/, '');

    var uri = setTemporaryFsByDefault(src);

    uri = fullPathToAppData(uri);
    uri = cdvfileToAppData(uri);

    return uri;
}","function func0(variable0) {
    variable0 = variable0.replace(/([^\/:])(\/\/)([^\/])/g, '$1/$3');
    variable0 = variable0.replace(/^[\\\/]{1,2}/, '');
    var variable1 = setTemporaryFsByDefault(variable0);
    variable1 = fullPathToAppData(variable1);
    variable1 = cdvfileToAppData(variable1);
    return variable1;
}",Prepares media src for internal usage,Convert a file path to an app data object .,Function to convert variable0 to variable1,1,Prediction1
"function MultiKeyCache(options) {
  options = options || {};

  var self = this;
  var dispose = options.dispose;

  options.dispose = function (key, value) {
    self._dispose(key);
    if (dispose) { dispose(key, value); }
  };

  this.cache = new LRU(options);
  this._keyMap = {};
}","function func0(variable0) {
    variable0 = variable0 || {};
    var variable1 = this;
    var variable2 = variable0.variable2;
    variable0.variable2 = function (key, value) {
        variable1._dispose(key);
        if (variable2) {
            variable2(key, value);
        }
    };
    this.cache = new LRU(variable0);
    this._keyMap = {};
}",Multi - Key LRU cache .,Creates a new Cache instance .,Creates a new LRU cache object .,1,Prediction2
"function encodeUserAuth(user) {
  if (!user) {
    return null;
  }

  var token = user.token;
  if (token) {
    var sha1 = typeof token === 'object' ? token.sha1 : token;
    return 'token ' + sha1;
  }

  return 'Basic ' + base64.encode(user.username + ':' + user.password)
}","function func0(variable0) {
    if (!variable0) {
        return null;
    }
    var variable1 = variable0.variable1;
    if (variable1) {
        var sha1 = typeof variable1 === 'object' ? variable1.sha1 : variable1;
        return 'token ' + sha1;
    }
    return 'Basic ' + base64.encode(variable0.username + ':' + variable0.password);
}",Generates the authentication parameter for the user Preference will be given to the token if it exists,Returns a string that can be used to generate a token,Creates a token string from the given options .,0,Tie
"function eatAttributeValue(stream) {
	const start = stream.pos;
	if (eatQuoted(stream)) {
		// Should return token that points to unquoted value.
		// Use stream readers’ public API to traverse instead of direct
		// manipulation
		const current = stream.pos;
		let valueStart, valueEnd;

		stream.pos = start;
		stream.next();
		valueStart = stream.start = stream.pos;

		stream.pos = current;
		stream.backUp(1);
		valueEnd = stream.pos;

		const result = token(stream, valueStart, valueEnd);
		stream.pos = current;
		return result;
	}

	return eatPaired(stream) || eatUnquoted(stream);
}","function func0(variable0) {
    const variable1 = variable0.pos;
    if (eatQuoted(variable0)) {
        const current = variable0.pos;
        let valueStart, valueEnd;
        variable0.pos = variable1;
        variable0.next();
        valueStart = variable0.variable1 = variable0.pos;
        variable0.pos = current;
        variable0.backUp(1);
        valueEnd = variable0.pos;
        const result = token(variable0, valueStart, valueEnd);
        variable0.pos = current;
        return result;
    }
    return eatPaired(variable0) || eatUnquoted(variable0);
}",Consumes attribute value from given location,ECMA - 262 13 . 3 . 5 Quoted Values,ECMA - 262 13 . 2,1,Tie
"function loadYamlFile(filepath) {
	try {
		return yaml.safeLoad(
			fs.readFileSync(filepath), {
				schema: yamlSchema,
				filename: filepath
			}
		);
	} catch (err) {
		return null;
	}
}","function func0(variable0) {
    try {
        return yaml.safeLoad(fs.readFileSync(variable0), {
            schema: yamlSchema,
            filename: variable0
        });
    } catch (err) {
        return null;
    }
}",Loads a YAML file and parses it into an Object .,Read a YAML file and return it,Parses a YAML file .,0,Prediction2
"function addHierarchicalFacet(hierarchicalFacet) {
    if (this.isHierarchicalFacet(hierarchicalFacet.name)) {
      throw new Error(
        'Cannot declare two hierarchical facets with the same name: `' + hierarchicalFacet.name + '`');
    }

    return this.setQueryParameters({
      hierarchicalFacets: this.hierarchicalFacets.concat([hierarchicalFacet])
    });
  }","function func0(variable0) {
    if (this.isHierarchicalFacet(variable0.name)) {
        throw new Error('Cannot declare two hierarchical facets with the same name: `' + variable0.name + '`');
    }
    return this.setQueryParameters({ hierarchicalFacets: this.hierarchicalFacets.concat([variable0]) });
}",Add a hierarchical facet to the hierarchicalFacets attribute of the helper configuration .,Adds a hierarchical facet to the query .,Declare a hierarchical facet,1,Tie